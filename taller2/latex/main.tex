\documentclass{article}
\usepackage{graphicx}
\usepackage[style=ieee]{biblatex} % Establecer el estilo de las referencias como IEEE
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{titletoc}
\usepackage{adjustbox}
\usepackage{amsmath}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{mdframed}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\hypersetup{
    colorlinks=true,
    linkcolor=blue, % Color del texto del enlace
    urlcolor=blue % Color del enlace
}

\usepackage{longtable} % Agrega el paquete longtable

\definecolor{mygreen}{RGB}{0,128,0}

\usepackage{array} % Para personalizar la tabla
\usepackage{booktabs} % Para líneas horizontales de mejor calidad
\usepackage{graphicx} % Paquete para incluir imágenes
\usepackage{float}

% Definir márgenes
\usepackage[margin=1in]{geometry}

\renewcommand{\contentsname}{\textcolor{mygreen}{Tabla de Contenidos}}

\begin{document}

\begin{titlepage}
    \centering
    % Logo de la Universidad
    \includegraphics[width=0.48\textwidth]{logo_universidad.png}
    \par\vspace{2cm}

    % Nombre de la Universidad y detalles del curso
    {\Large \textbf{Universidad Nacional de Colombia} \par}
    \vspace{0.5cm}
    {\large Ingeniería de Sistemas y Computación \par}
    {\large 2025969 Modelos estocásticos y simulación en computación y comunicaciones (01)\par}
    \vspace{3cm}

    % Detalles del laboratorio y actividad
    {\large \textbf{Taller 2} \par}
    \vspace{3cm}

    % Lista de integrantes
    {\large \textbf{Integrantes:} \par}
    \vspace{0.5cm}
    \begin{tabular}{ll}
    Javier Andrés Tarazona Jiménez & jtarazonaj@unal.edu.co \\
    Yenifer Yulieth Mora Segura & ymoras@unal.edu.co \\
    Juan Esteban Carranza Salazar & jcarranza@unal.edu.co \\
    Grevy Joner Rincon Mejia & grrinconm@unal.edu.co \\
    Jefferson Duvan Ramirez Castañeda & jeramirezca@unal.edu.co \\
    Javier Andres Carrillo Carrasco & jacarrillo@unal.edu.co \\
    Diego Nicolas Ramirez Maldonado & dieramirezma@unal.edu.co \\
    \end{tabular}
    \par\vspace{3cm}

    % Fecha
    {\large Julio 21 de 2025 \par}
\end{titlepage}

\tableofcontents % Inserta la tabla de contenidos

\newpage % Salto de página para separar la tabla de contenidos del contenido del documento

% Contenido del artículo----------------------------------------------------------

%---------------------------------------------------------------------------------
% Intro --------------------------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Introducción}\label{sec:intr}


%---------------------------------------------------------------------------------
% Marco Teórico ------------------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Marco Teórico}\label{sec:marc}

\subsection{Modelos de Colas}
\subsubsection{Definición y Características}

Un \textbf{Sistema de Colas} es una estructura matemática utilizada para modelar situaciones en las que los "clientes" (que pueden ser personas, datos o tareas) llegan para ser atendidos por uno o más servidores. Este modelo es fundamental en áreas como telecomunicaciones, manufactura, logística, atención al cliente, y sistemas de información, ya que permite predecir y optimizar el rendimiento de sistemas que operan bajo condiciones de congestión o espera.

\begin{itemize}
    \item \textbf{Sistema de Colas:} Se define como un proceso estocástico en el que los clientes llegan a un punto de servicio y deben esperar hasta que el servicio esté disponible. Estos sistemas son caracterizados por tres componentes principales:
    \begin{itemize}
        \item \textbf{Llegadas:} El proceso que describe la llegada de clientes al sistema. Este proceso suele modelarse utilizando distribuciones de probabilidad, como la \textit{distribución de Poisson}, que describe el tiempo entre llegadas de manera aleatoria.
        \item \textbf{Cola:} El espacio de espera donde los clientes se sitúan hasta que se les ofrece servicio. La cola puede ser \textit{finita o infinita} dependiendo del modelo y de las restricciones del sistema.
        \item \textbf{Servicio:} El proceso mediante el cual el cliente es atendido por uno o más servidores. El tiempo de servicio es típicamente modelado utilizando distribuciones de probabilidad como la \textit{distribución exponencial}, la cual asume que el tiempo entre la finalización de un servicio y el inicio de otro es aleatorio y no sigue un patrón predecible.
    \end{itemize}
    
    \item \textbf{Características Clave de los Sistemas de Colas:} Los sistemas de colas se definen por varios factores que determinan su comportamiento y rendimiento. Las principales características de los sistemas de colas incluyen:
    \begin{itemize}
        \item \textbf{Tasa de Llegada (\(\lambda\)):} Es la frecuencia con la que los clientes llegan al sistema. Generalmente, se modela utilizando una \textit{distribución de Poisson} para representar llegadas independientes entre sí, lo que implica que el tiempo entre llegadas sigue una distribución \textit{exponencial}.
        \item \textbf{Tasa de Servicio (\(\mu\)):} Es la frecuencia con la que el servidor atiende a los clientes. Normalmente, el tiempo de servicio es representado por una distribución \textit{exponencial}.
        \item \textbf{Capacidad del Sistema:} La cantidad máxima de clientes que el sistema puede manejar en un momento dado. Algunos modelos de colas permiten una \textit{cola infinita}, mientras que otros pueden tener un número máximo de clientes que el sistema puede aceptar (por ejemplo, M/M/1 o M/M/c).
        \item \textbf{Número de Servidores (c):} En muchos sistemas de colas, un solo servidor puede atender a los clientes (como en el modelo M/M/1), pero en otros sistemas puede haber múltiples servidores trabajando simultáneamente en el servicio de diferentes clientes (por ejemplo, en el modelo M/M/c).
        \item \textbf{Disciplina de Servicio:} Define el orden en el que los clientes son atendidos dentro de la cola. Las más comunes incluyen \textit{FIFO} (First In, First Out), \textit{LIFO} (Last In, First Out), o \textit{SJF} (Shortest Job First). En la mayoría de los sistemas de colas, se asume que la disciplina es FIFO.
        \item \textbf{Tiempo de Espera:} Es el tiempo que un cliente pasa esperando en la cola antes de ser atendido. Es una de las métricas más importantes para evaluar la eficiencia de un sistema de colas, ya que refleja el nivel de congestión del sistema.
        \item \textbf{Utilización del Servidor (\(\rho\)):} Este parámetro describe el porcentaje de tiempo que un servidor está ocupado atendiendo a los clientes. Se calcula como la relación entre la tasa de llegada (\(\lambda\)) y la tasa de servicio (\(\mu\)):  
        \[
        \rho = \frac{\lambda}{\mu}
        \]
        Si \(\rho\) es cercano a 1, significa que el servidor está muy ocupado, lo que puede generar largos tiempos de espera y alta congestión.
    \end{itemize}

    \item \textbf{Importancia y Aplicaciones:} El estudio de los sistemas de colas es esencial para entender y optimizar el rendimiento de sistemas reales en los que se presentan tiempos de espera y congestión. Estos modelos no solo son útiles para analizar la eficiencia de sistemas de servicio, sino que también ayudan en la \textit{gestión de recursos} y la \textit{planificación operativa}. Ejemplos comunes de aplicaciones incluyen:
    \begin{itemize}
        \item \textbf{Telecomunicaciones:} En redes de computadoras y telecomunicaciones, los paquetes de datos pueden ser modelados como clientes en un sistema de colas, y los servidores como enrutadores o nodos de la red.
        \item \textbf{Manufactura:} En las líneas de producción, los productos que deben ser procesados en varias etapas son modelados como clientes que esperan en las estaciones de trabajo.
        \item \textbf{Servicios al Cliente:} En áreas como bancos, supermercados o servicios en línea, los clientes esperan ser atendidos, y el sistema de colas ayuda a optimizar la cantidad de personal necesario en diferentes momentos del día.
    \end{itemize}
\end{itemize}

\subsubsection{Clasificación de los Sistemas de Colas}
La clasificación de los sistemas de colas se basa en diversas características que determinan su estructura y comportamiento. Cada tipo de sistema tiene distintas implicaciones en su modelado matemático, así como en su aplicación práctica. Los sistemas de colas pueden clasificarse de acuerdo con varios factores, como el número de servidores, el comportamiento de las llegadas y los tiempos de servicio, y la capacidad del sistema.

A continuación, se presenta una clasificación de los sistemas de colas, basada en sus principales características estructurales y operativas.

\begin{itemize}
    \item \textbf{Según el Número de Servidores:}
    \begin{itemize}
        \item \textbf{M/M/1:} Este es el modelo más simple y comúnmente utilizado, donde 'M' representa una distribución de Poisson para las llegadas y una distribución exponencial para los tiempos de servicio. En este modelo, hay un único servidor (\(1\)), lo que significa que los clientes deben esperar para ser atendidos si el servidor está ocupado. Este modelo es ampliamente utilizado en situaciones con baja carga de tráfico o cuando solo está disponible un servidor para atender las solicitudes.
        \item \textbf{M/M/c:} En este caso, \(c\) representa el número de servidores. Este modelo es una extensión del M/M/1, y se utiliza cuando varios servidores están disponibles para atender a los clientes. Este tipo de sistema se usa comúnmente en centros de llamadas, hospitales o estaciones de servicio donde múltiples recursos están disponibles.
    \end{itemize}
    
    \item \textbf{Según la Distribución de las Llegadas:}
    \begin{itemize}
        \item \textbf{M/M/1:} En este caso, las llegadas siguen una distribución de Poisson, lo que implica que las llegadas son independientes y el tiempo entre llegadas sigue una distribución exponencial. Este modelo es adecuado para sistemas con llegadas aleatorias y sin patrones específicos.
        \item \textbf{G/G/1:} En este modelo, las llegadas y los tiempos de servicio siguen distribuciones generales, es decir, no están restringidos a distribuciones específicas como la Poisson o exponencial. Este modelo es más flexible y se utiliza cuando las llegadas o los tiempos de servicio no siguen una distribución simple y se requiere un modelado más general.
    \end{itemize}
    
    \item \textbf{Según la Disciplina de Servicio:}
    \begin{itemize}
        \item \textbf{FIFO (First In, First Out):} Esta es la disciplina de servicio más común y se asume en la mayoría de los modelos de colas. Los clientes son atendidos en el orden en que llegan al sistema, es decir, el primero en llegar es el primero en ser atendido.
        \item \textbf{LIFO (Last In, First Out):} En esta disciplina, el último cliente en llegar es el primero en ser atendido. Este modelo es menos común, pero puede aplicarse en situaciones donde la atención urgente a los clientes más recientes es prioritaria, como en ciertos sistemas de caché de computadoras.
        \item \textbf{SJF (Shortest Job First):} En este modelo, los clientes que requieren el servicio más corto son atendidos primero. Esta disciplina se utiliza principalmente en entornos donde los recursos deben asignarse de manera eficiente, como en el procesamiento de tareas informáticas.
    \end{itemize}
    
    \item \textbf{Según la Capacidad del Sistema:}
    \begin{itemize}
        \item \textbf{Sistema de Cola Infinita:} En este tipo de sistema, la capacidad de la cola no está limitada. Esto significa que no hay restricciones sobre cuántos clientes pueden esperar en la cola. Este modelo es adecuado para sistemas de colas con una alta demanda y sin límites físicos, como ciertos sistemas informáticos o redes de telecomunicaciones.
        \item \textbf{Sistema de Cola Finita:} En contraste, en un sistema de cola finita, existe un límite máximo en el número de clientes que pueden estar esperando en la cola en un momento dado. Los clientes adicionales que lleguen cuando la cola esté llena serán rechazados o perderán el servicio. Este tipo de sistema es más adecuado para entornos donde los recursos son limitados, como en estaciones de servicio o ciertos tipos de servicios al cliente.
    \end{itemize}
\end{itemize}

\subsubsection{Aplicaciones de los Modelos de Colas}

Los modelos de colas son fundamentales en diversas disciplinas como ingeniería, informática y telecomunicaciones, así como en otros sectores donde la eficiencia del servicio es crucial. La teoría de colas se aplica en situaciones que involucran congestión, asignación de recursos limitados y tiempos de espera. Su utilización adecuada puede generar mejoras sustanciales en la gestión de recursos y la optimización de procesos.

A continuación, se describen algunas de las aplicaciones más relevantes de los modelos de colas en distintos campos:

\begin{itemize}
    \item \textbf{Telecomunicaciones:}
    En las redes de telecomunicaciones, los sistemas de colas son fundamentales para modelar el comportamiento de las transmisiones de datos. Los paquetes de datos, que actúan como "clientes", llegan a un servidor de red (como un enrutador o un conmutador) y esperan para ser procesados o transmitidos. Los modelos de colas permiten evaluar la congestión en las redes y diseñar algoritmos para asignar recursos de manera eficiente, minimizando el tiempo de espera y la probabilidad de pérdida de paquetes. En particular, el modelo \textit{M/M/1} es ampliamente utilizado para estudiar redes con un solo servidor, mientras que modelos más complejos como \textit{M/M/c} son utilizados para estudiar redes con múltiples servidores.
    
    Los sistemas de colas también se utilizan en el análisis de la capacidad de redes celulares y de Internet, optimizando la asignación de recursos en momentos de alta demanda. El tráfico de datos en las redes de telecomunicaciones puede ser modelado como un proceso de llegada estocástico, y el rendimiento de la red puede ser analizado en términos de la tasa de pérdida de paquetes, el tiempo de espera y la utilización de los recursos.

    \item \textbf{Sistemas de Computación y Redes:}
    En los sistemas informáticos, los modelos de colas se emplean para analizar la gestión de tareas en servidores, sistemas de bases de datos y procesadores. La ejecución de tareas en un servidor puede ser vista como un sistema de colas, donde los procesos llegan para ser ejecutados y deben esperar su turno en la cola. Estos modelos son esenciales en la planificación de cargas de trabajo, la asignación de recursos y la gestión de sistemas multitarea.

    En las redes de computadoras, los paquetes de datos que esperan ser transmitidos a través de los nodos de la red se tratan como clientes en un sistema de colas. La optimización de redes de computadoras implica minimizar la congestión y los retrasos en las transmisiones, lo que se puede lograr mediante el ajuste adecuado de los recursos disponibles, el enrutamiento de paquetes y la gestión de la calidad del servicio (QoS). Los modelos de colas también son cruciales para la gestión de centros de datos y servidores de bases de datos, donde múltiples procesos compiten por el acceso a recursos limitados.

    \item \textbf{Manufactura y Producción:}
    En el ámbito de la manufactura, los modelos de colas son utilizados para estudiar las líneas de producción, en las que los productos o materiales deben pasar a través de diferentes estaciones de trabajo. Los productos que esperan ser procesados son modelados como clientes, y las estaciones de trabajo actúan como servidores que brindan el servicio requerido. Estos modelos permiten evaluar la eficiencia de las líneas de producción, identificando posibles cuellos de botella y optimizando el flujo de materiales.

    Los sistemas de colas también se utilizan en la planificación de la capacidad de los sistemas de producción, ayudando a decidir el número óptimo de estaciones de trabajo, el número de operarios y el diseño de la línea de producción para minimizar los tiempos de espera y mejorar la eficiencia operativa. En un entorno de producción, los clientes pueden representar productos que deben ser ensamblados, y los servidores son las máquinas o estaciones de trabajo que realizan las tareas correspondientes.

    \item \textbf{Servicios Bancarios y Financieros:}
    Los sistemas de colas son ampliamente aplicados en la gestión de servicios bancarios y financieros, donde los clientes esperan ser atendidos por cajeros o asesores. En este caso, el objetivo es minimizar los tiempos de espera para los clientes y, al mismo tiempo, garantizar una utilización eficiente de los recursos disponibles, como cajeros y asesores. Los modelos de colas pueden ayudar a determinar el número adecuado de cajeros o personal de atención en diferentes momentos del día, basándose en la tasa de llegada de clientes y el tiempo promedio de servicio.

    Los sistemas de colas también se utilizan en el análisis de los servicios automatizados, como los cajeros automáticos (ATM), donde los clientes realizan transacciones sin la necesidad de interacción humana. En estos sistemas, los modelos de colas permiten optimizar la ubicación de los cajeros, la cantidad de terminales disponibles y la gestión de las demandas fluctuantes en función de la hora del día.

    \item \textbf{Atención al Cliente y Centros de Llamadas:}
    En el ámbito de la atención al cliente, los modelos de colas son esenciales para gestionar centros de llamadas y otros servicios donde los clientes deben esperar ser atendidos. Los centros de llamadas, donde los clientes llaman para obtener soporte o información, pueden modelarse como sistemas de colas, con las llamadas representando a los clientes y los operadores como los servidores. La optimización de estos sistemas involucra determinar la cantidad adecuada de operadores para minimizar los tiempos de espera y mejorar la calidad del servicio al cliente.

    Los modelos de colas también se utilizan en el análisis de la eficiencia de los sistemas automáticos de atención al cliente, como los sistemas IVR (respuesta de voz interactiva), que permiten que los clientes interactúen con un sistema automatizado antes de ser atendidos por un operador. En estos casos, los modelos de colas pueden ayudar a evaluar el impacto de la automatización en los tiempos de espera y en la satisfacción del cliente.

    \item \textbf{Transporte Público:}
    En el transporte público, los sistemas de colas se utilizan para modelar el flujo de pasajeros en estaciones de trenes, aeropuertos y paradas de autobuses. Los modelos permiten estudiar la distribución de los pasajeros en diferentes rutas y determinar el número óptimo de vehículos necesarios en cada momento para satisfacer la demanda de manera eficiente. Los modelos de colas también se aplican para gestionar la congestión en las horas punta y reducir los tiempos de espera de los pasajeros.

    Además, estos modelos pueden ser útiles en el análisis de la asignación de recursos, como la cantidad de vehículos, la frecuencia de los viajes y la distribución de los pasajeros en las diferentes rutas del sistema de transporte. La optimización de estos aspectos ayuda a mejorar la eficiencia operativa y la satisfacción de los usuarios.

    \item \textbf{Salud y Hospitales:}
    En el sector salud, los modelos de colas se aplican para estudiar el flujo de pacientes a través de diferentes etapas de atención, como consultas médicas, diagnósticos y procedimientos. Estos modelos permiten analizar la eficiencia de los recursos, como médicos, enfermeras y equipos de diagnóstico, y optimizar la programación de citas para reducir los tiempos de espera y mejorar la calidad del servicio. Además, los modelos de colas se utilizan para gestionar la capacidad de los hospitales y las unidades de emergencia, donde el número de pacientes puede superar rápidamente la capacidad del sistema de salud.

    \item \textbf{Sistemas de Distribución y Logística:}
    En la logística y distribución, los modelos de colas se utilizan para modelar los centros de distribución, almacenes y líneas de ensamblaje. Los productos o materiales en espera de ser procesados o distribuidos son tratados como clientes en un sistema de colas. Los modelos permiten optimizar la operación de estos sistemas, minimizando los tiempos de espera y maximizando la eficiencia operativa.

    Además, los modelos de colas se utilizan en la simulación de sistemas de gestión de inventarios y distribución de recursos, ayudando a mejorar la planificación de la cadena de suministro, la asignación de recursos y la programación de las entregas.

\end{itemize}

\subsection{Modelo M/M/1}
\subsubsection{Descripción Técnica del Modelo}

El modelo M/M/1 es uno de los modelos más simples y fundamentales en la teoría de colas, utilizado para describir sistemas en los que los clientes llegan de manera aleatoria y deben esperar para ser atendidos por un solo servidor. La notación \textit{M/M/1} se desglosa de la siguiente manera:

\begin{itemize}
    \item \textbf{M} (Markoviano) para las llegadas: El proceso de llegadas de clientes sigue una \textit{distribución de Poisson}, lo que implica que las llegadas son aleatorias y ocurren a una tasa constante, con interludios entre llegadas que siguen una \textit{distribución exponencial}.
    
    \item \textbf{M} (Markoviano) para el servicio: El tiempo de servicio sigue una \textit{distribución exponencial}, lo que implica que la tasa de servicio es constante y cada cliente es atendido de forma independiente de los anteriores.
    
    \item \textbf{1}: Indica que el sistema cuenta con \textbf{un solo servidor} que atiende a los clientes que llegan.
\end{itemize}

Este modelo se basa en suponer que tanto las llegadas como los tiempos de servicio son procesos estocásticos, y como tal, la teoría de colas aplicada al modelo M/M/1 está fuertemente influenciada por la teoría de procesos de Markov.

\begin{itemize}
    \item \textbf{Flujo del Modelo M/M/1:} En este modelo, los clientes llegan a la cola según un proceso de Poisson, y los tiempos de servicio se distribuyen de forma exponencial. Cuando un cliente llega y el servidor está ocupado, el cliente debe esperar en la cola hasta que el servidor se encuentre disponible. Si el servidor está libre en el momento de la llegada, el cliente es atendido inmediatamente.
    
    \item \textbf{Funcionamiento:} El sistema opera bajo un conjunto de reglas que permiten la modelización de los siguientes aspectos:
    \begin{itemize}
        \item \textit{Llegadas:} Las llegadas de clientes son completamente aleatorias, con una tasa de llegada promedio de \( \lambda \) clientes por unidad de tiempo. La llegada de clientes es independiente de las llegadas anteriores, lo que implica que las llegadas siguen un proceso de \textit{Poisson}.
        
        \item \textit{Servicio:} El servidor atiende a los clientes según una tasa de servicio \( \mu \), también constante. Los tiempos de servicio son independientes entre sí y siguen una distribución \textit{exponencial}, lo que significa que el tiempo de servicio entre cada cliente es aleatorio, pero con una tasa promedio de \( \mu \).
    \end{itemize}
    
    \item \textbf{Representación Matemática:} La tasa de utilización del servidor \( \rho \) es un parámetro clave del modelo M/M/1 y se define como la relación entre la tasa de llegada \( \lambda \) y la tasa de servicio \( \mu \):
    \[
    \rho = \frac{\lambda}{\mu}
    \]
    Donde \( \rho \) debe ser menor que 1 para que el sistema sea estable. Si \( \rho \) es mayor o igual a 1, el sistema no es estable y los tiempos de espera pueden crecer indefinidamente.
    
    \item \textbf{Importancia del Modelo M/M/1:} El modelo M/M/1 se utiliza como base para el análisis de otros sistemas de colas más complejos. Su simplicidad y facilidad de análisis matemático lo hacen ideal para modelar y estudiar el comportamiento de sistemas básicos de espera. A pesar de su simplicidad, proporciona una visión clara de cómo el comportamiento de los sistemas de colas depende de las tasas de llegada y servicio, y cómo estos factores afectan las métricas clave como los tiempos de espera y la utilización del servidor.
    
    Este modelo sirve como una aproximación útil en muchos escenarios prácticos donde el servicio es aleatorio y el sistema se puede simplificar a un solo servidor, permitiendo realizar estimaciones y predicciones sobre el rendimiento de sistemas reales.
\end{itemize}

\subsubsection{Supuestos y Restricciones}

El modelo M/M/1, aunque es uno de los más sencillos y utilizados en la teoría de colas, se basa en una serie de supuestos que deben cumplirse para que los resultados del modelo sean válidos. Estos supuestos permiten la simplificación matemática del modelo, pero también presentan limitaciones en su aplicabilidad en escenarios del mundo real. A continuación, se describen los supuestos fundamentales y las restricciones asociadas al modelo M/M/1:

\begin{itemize}
    \item \textbf{Llegadas de Clientes Según una Distribución de Poisson:} 
    El modelo M/M/1 asume que las llegadas de clientes siguen una \textit{distribución de Poisson}. Esto implica que las llegadas son completamente aleatorias y ocurren a una tasa constante \( \lambda \), con intervalos de tiempo entre llegadas que siguen una \textit{distribución exponencial}. En la práctica, esto puede ser una simplificación excesiva en muchos sistemas, ya que en algunos contextos las llegadas pueden seguir distribuciones más complejas.
    
    \item \textbf{Tiempo de Servicio Exponencial:} 
    El tiempo que cada cliente pasa siendo atendido sigue una \textit{distribución exponencial} con tasa \( \mu \). Esto implica que el tiempo de servicio es aleatorio y tiene una media constante. En muchos casos prácticos, los tiempos de servicio pueden no ser exponenciales y pueden variar dependiendo del tipo de tarea, lo que limita la aplicabilidad directa del modelo.
    
    \item \textbf{Un Solo Servidor:} 
    El modelo M/M/1 se limita a un sistema con \textbf{un solo servidor} (\(1\)). Este supuesto implica que solo hay un punto de servicio para todos los clientes que llegan, lo cual es una simplificación en sistemas más complejos que cuentan con múltiples servidores. Los sistemas con varios servidores requieren la extensión del modelo M/M/1, como el modelo M/M/c.
    
    \item \textbf{Disciplina de Servicio FIFO:} 
    Se asume que los clientes son atendidos siguiendo la disciplina \textit{FIFO} (First In, First Out), lo que significa que el cliente que llega primero será el primero en ser atendido. En la práctica, sin embargo, existen otras disciplinas de servicio, como \textit{LIFO} (Last In, First Out) o \textit{SJF} (Shortest Job First), que pueden no cumplir con esta suposición y pueden alterar significativamente el comportamiento del sistema.
    
    \item \textbf{Capacidad del Sistema Infinita:} 
    El modelo M/M/1 asume que la cola puede almacenar un número ilimitado de clientes. Esto significa que no hay restricción en el número de clientes que pueden esperar para ser atendidos. En sistemas reales, la capacidad de las colas suele ser limitada, lo que puede llevar a la pérdida de clientes cuando el sistema está lleno, lo que no está reflejado en el modelo M/M/1.
    
    \item \textbf{Estabilidad del Sistema (\( \rho < 1 \)):} 
    Para que el sistema M/M/1 sea estable, se requiere que la tasa de llegada \( \lambda \) sea menor que la tasa de servicio \( \mu \), es decir, que \( \rho = \frac{\lambda}{\mu} < 1 \). Este supuesto implica que el servidor es lo suficientemente rápido como para atender a todos los clientes que llegan al sistema sin que la cola crezca de manera indefinida. Si \( \rho \geq 1 \), el sistema será inestable y los tiempos de espera crecerán sin límite, lo que es una restricción importante a tener en cuenta en la práctica.
\end{itemize}

 \textbf{Restricciones y Limitaciones del Modelo:}
El modelo M/M/1 es extremadamente útil para análisis básicos y sirve como una aproximación adecuada en muchas situaciones. Sin embargo, las suposiciones de llegadas de Poisson, tiempos de servicio exponenciales, un solo servidor y cola infinita son simplificaciones que no siempre se ajustan a la realidad. En escenarios más complejos, como sistemas con múltiples servidores, tiempos de servicio no exponenciales o llegadas que no siguen una distribución de Poisson, es necesario considerar modelos más avanzados o utilizar la simulación de colas.

A pesar de sus limitaciones, el modelo M/M/1 sigue siendo una herramienta valiosa para comprender los principios fundamentales de la teoría de colas y sirve como base para la construcción de modelos más complejos y realistas.

\subsubsection{Propiedades Clave}

El modelo M/M/1, a pesar de su simplicidad, presenta varias propiedades fundamentales que permiten analizar su comportamiento y rendimiento. Estas propiedades son esenciales para comprender cómo las tasas de llegada y servicio afectan las métricas clave del sistema, como los tiempos de espera y la utilización del servidor. A continuación, se detallan las propiedades más importantes de este modelo:

\begin{itemize}
    \item \textbf{Utilización del Servidor (\(\rho\)):} 
    La tasa de utilización del servidor, denotada por \( \rho \), es una medida crucial del modelo M/M/1. Se define como la relación entre la tasa de llegada \( \lambda \) y la tasa de servicio \( \mu \):

    \[
    \rho = \frac{\lambda}{\mu}
    \]

    Esta propiedad indica la fracción del tiempo que el servidor está ocupado. Para que el sistema sea estable, \( \rho \) debe ser menor que 1. Si \( \rho \) es igual o superior a 1, el sistema no es estable, lo que puede llevar a tiempos de espera infinitos. En la práctica, \( \rho \) proporciona una indicación del nivel de carga del sistema: valores cercanos a 1 indican que el sistema está cerca de su capacidad máxima.

    \item \textbf{Tiempo Promedio de Espera en la Cola (\( W_q \)):} 
    El tiempo promedio que un cliente pasa esperando en la cola antes de ser atendido es una métrica crítica en los sistemas de colas. En el modelo M/M/1, el tiempo de espera en la cola está dado por la siguiente fórmula:

    \[
    W_q = \frac{\lambda}{\mu (\mu - \lambda)}
    \]

    Este tiempo es inversamente proporcional a la diferencia entre la tasa de servicio \( \mu \) y la tasa de llegada \( \lambda \). A medida que la tasa de llegada aumenta, el tiempo de espera en la cola también aumenta, lo que subraya la importancia de mantener un balance adecuado entre estas dos tasas para evitar largas colas.

    \item \textbf{Tiempo Promedio de Espera en el Sistema (\( W \)):} 
    El tiempo total que un cliente pasa en el sistema, desde su llegada hasta que termina su servicio, es la suma del tiempo de espera en la cola y el tiempo de servicio. En el modelo M/M/1, el tiempo promedio de espera en el sistema se calcula mediante la siguiente fórmula:

    \[
    W = W_q + \frac{1}{\mu}
    \]

    Dado que el tiempo de servicio es inversamente proporcional a \( \mu \), un mayor valor de \( \mu \) (es decir, un servidor más rápido) resulta en un menor tiempo de espera total en el sistema.

    \item \textbf{Número Promedio de Clientes en la Cola (\( L_q \)):} 
    El número promedio de clientes que se encuentran en la cola en un momento dado es una propiedad fundamental en el análisis de sistemas de colas. En el modelo M/M/1, este número se calcula como:

    \[
    L_q = \lambda^2 / (\mu (\mu - \lambda))
    \]

    Este valor refleja la acumulación de clientes en espera y es mayor cuando \( \lambda \) se acerca a \( \mu \), lo que indica que el sistema está cerca de su capacidad máxima.

    \item \textbf{Número Promedio de Clientes en el Sistema (\( L \)):} 
    El número total de clientes en el sistema (que incluye tanto los clientes en la cola como aquellos siendo atendidos) se calcula sumando el número promedio de clientes en la cola \( L_q \) y la tasa de servicio \( \lambda / \mu \), es decir, el número promedio de clientes siendo atendidos:

    \[
    L = L_q + \frac{\lambda}{\mu}
    \]

    Esta propiedad proporciona una medida global de la cantidad de clientes que están siendo atendidos y esperando en el sistema. Al igual que con los tiempos de espera, el número de clientes en el sistema aumenta a medida que \( \lambda \) se aproxima a \( \mu \).

    \item \textbf{Probabilidad de que el Sistema esté Vacío (\( P_0 \)):} 
    La probabilidad de que no haya ningún cliente en el sistema en un momento dado, es decir, la probabilidad de que el sistema esté vacío, está dada por:

    \[
    P_0 = 1 - \rho
    \]

    Este valor es importante porque representa la probabilidad de que el servidor no esté ocupado, lo cual es relevante para la gestión de recursos y la evaluación de la eficiencia operativa.

    \item \textbf{Distribución de Probabilidad de Clientes en el Sistema:}
    La probabilidad de que haya \( n \) clientes en el sistema en un momento dado, denotada como \( P_n \), se puede calcular mediante la fórmula:

    \[
    P_n = (1 - \rho) \rho^n
    \]

    Esta fórmula describe cómo varía la probabilidad de que el sistema contenga un número determinado de clientes. La distribución muestra que a medida que \( n \) aumenta, la probabilidad de tener muchos clientes en el sistema disminuye exponencialmente, lo que indica que el modelo M/M/1 tiende a tener menos clientes a medida que la carga de tráfico disminuye.

\end{itemize}

\subsection{Teoría Matemática de las Colas}
\subsubsection{Teoría Probabilística Aplicada}
La modelación de sistemas de colas recurre a herramientas de probabilidad y procesos estocásticos que permitan describir la evolución del número de clientes en el sistema. A continuación se presentan los conceptos y resultados más generales:

\begin{itemize}
    \item \textbf{Proceso de Poisson y tiempos exponenciales:}  
    Un proceso de llegadas se modela frecuentemente como un \textit{proceso de Poisson} de tasa \(\lambda\), de modo que los intervalos entre llegadas son variables aleatorias \(\{T_i\}\) independientes con distribución exponencial
    \[
      \Pr\{T_i > t\} = e^{-\lambda t}.
    \]
    De forma análoga, si los tiempos de servicio son exponenciales de parámetro \(\mu\), se aprovecha la propiedad \textit{memoryless}
    \(\Pr\{T>s+t\mid T>s\}=\Pr\{T>t\}\).
    
    \item \textbf{Procesos de nacimiento–muerte:}  
    El número de clientes \(X(t)\) en un sistema de colas puede describirse por un proceso de nacimiento y muerte con tasas de nacimiento \(\{\lambda_n\}\) y de muerte \(\{\mu_n\}\). La matriz generadora \(Q=[q_{ij}]\) viene dada por
    \[
      q_{n,n+1}=\lambda_n,\quad
      q_{n,n-1}=\mu_n,\quad
      q_{n,n}=-(\lambda_n+\mu_n).
    \]
    
    \item \textbf{Ecuaciones de Kolmogorov (forward):}  
    Las probabilidades transitorias \(P_n(t)=\Pr\{X(t)=n\}\) satisfacen
    \[
      \frac{d}{dt}P_n(t)
        = \lambda_{n-1}P_{n-1}(t)
        + \mu_{n+1}P_{n+1}(t)
        - (\lambda_n+\mu_n)P_n(t),
    \]
    con condiciones de frontera adecuadas y \(\sum_nP_n(t)=1\).
    
    \item \textbf{Distribución estacionaria:}  
    En régimen estacionario (\(dP_n/dt=0\)) las \textit{ecuaciones de balance}  
    \(\lambda_{n-1}\pi_{n-1} + \mu_{n+1}\pi_{n+1} = (\lambda_n+\mu_n)\pi_n\)  
    se complementan con la normalización \(\sum_n\pi_n=1\). Para procesos birth–death se obtiene
    \[
      \pi_n = \pi_0 \prod_{i=0}^{n-1}\frac{\lambda_i}{\mu_{i+1}}.
    \]
    
    \item \textbf{PASTA (Poisson Arrivals See Time Averages):}  
    Cuando las llegadas siguen Poisson, la fracción de llegadas que encuentran el sistema en estado \(n\) coincide con la probabilidad estacionaria \(\pi_n\). Esto confirma la validez de comparar medidas de simulación (por llegada) con valores teóricos.
    
    \item \textbf{Ley de Little:}  
    De manera completamente general, en cualquier sistema estable se cumple
    \[
      L = \lambda \, W,
    \]
    donde \(L\) es el número promedio de clientes en el sistema, \(\lambda\) la tasa efectiva de llegadas, y \(W\) el tiempo promedio que un cliente pasa en el sistema.
\end{itemize}


\subsubsection{Cálculos de Probabilidades en Sistemas de Colas}
El cálculo de probabilidades en sistemas de colas es fundamental para entender el comportamiento de los sistemas y predecir su rendimiento en diferentes condiciones. A continuación, se presentan los principales métodos para calcular probabilidades clave que describen el estado del sistema, como el número de clientes en la cola y el tiempo de espera.

\begin{itemize}
    \item \textbf{Distribución Estacionaria:}  
    En los sistemas de colas en régimen estacionario, las probabilidades de encontrar el sistema en un estado específico (\(n\) clientes en el sistema) son fundamentales para la caracterización del sistema. Para los sistemas de colas clásicos como el modelo M/M/1, la distribución estacionaria \(P_n\) de encontrar \(n\) clientes en el sistema está dada por la fórmula
    \[
      P_n = (1 - \rho)\,\rho^n, \quad \text{para} \quad n = 0, 1, 2, \dots,
    \]
    donde \( \rho = \frac{\lambda}{\mu} \) es la tasa de utilización del servidor. Este modelo describe cómo la probabilidad de que el sistema contenga \(n\) clientes decae exponencialmente a medida que aumenta \(n\), con una probabilidad máxima de que el sistema esté vacío (\(P_0\)).

    \item \textbf{Probabilidad de que el sistema esté vacío (\(P_0\)):}  
    En cualquier sistema de colas M/M/1, la probabilidad de que no haya clientes en el sistema, es decir, que el sistema esté vacío, es una métrica clave para la evaluación del rendimiento del sistema. Para el modelo M/M/1, esta probabilidad se calcula como:
    \[
      P_0 = 1 - \rho = 1 - \frac{\lambda}{\mu}.
    \]
    Si el sistema está vacío, significa que el servidor está disponible para atender a un nuevo cliente.

    \item \textbf{Número Promedio de Clientes en el Sistema (\(L\)):}  
    El número promedio de clientes en el sistema, que incluye tanto a los clientes en la cola como los que están siendo atendidos, se calcula utilizando la probabilidad estacionaria y la distribución de Poisson. Para el modelo M/M/1, el número promedio de clientes en el sistema \(L\) es dado por:
    \[
      L = \sum_{n=0}^{\infty} n\,P_n = \frac{\rho}{1 - \rho}.
    \]
    Esta fórmula indica que el número promedio de clientes en el sistema aumenta con la tasa de llegada \(\lambda\) y disminuye con la tasa de servicio \(\mu\). A medida que la tasa de llegada se aproxima a la tasa de servicio (\(\rho \to 1\)), el número promedio de clientes en el sistema crece sin límites.

    \item \textbf{Tiempo Promedio de Espera en el Sistema (\(W\)):}  
    El tiempo promedio que un cliente pasa en el sistema, desde que llega hasta que es atendido, está relacionado con el número promedio de clientes en el sistema a través de la conocida \textit{ley de Little}, que establece que:
    \[
      W = \frac{L}{\lambda}.
    \]
    Esto implica que el tiempo promedio de espera aumenta conforme se incrementa el número de clientes en el sistema, lo que a su vez depende de la tasa de llegada y la tasa de servicio.

    \item \textbf{Tiempo Promedio de Espera en la Cola (\(W_q\)):}  
    El tiempo promedio que un cliente pasa esperando en la cola antes de ser atendido es una métrica clave para evaluar la eficiencia de un sistema de colas. En el modelo M/M/1, el tiempo de espera en la cola \(W_q\) se puede calcular con la siguiente fórmula:
    \[
      W_q = \frac{\lambda}{\mu(\mu - \lambda)}.
    \]
    Este tiempo es inversamente proporcional a la diferencia entre la tasa de servicio \( \mu \) y la tasa de llegada \( \lambda \). A medida que la tasa de llegada aumenta, el tiempo de espera en la cola se incrementa, lo que subraya la importancia de gestionar adecuadamente la tasa de servicio.

    \item \textbf{Número Promedio de Clientes en la Cola (\(L_q\)):}  
    El número promedio de clientes que esperan en la cola, antes de ser atendidos, se obtiene mediante la fórmula:
    \[
      L_q = \lambda^2 / (\mu(\mu - \lambda)).
    \]
    Similar al tiempo de espera, el número de clientes en la cola aumenta con la tasa de llegada y disminuye con la tasa de servicio. Cuando la tasa de llegada \( \lambda \) se aproxima a la tasa de servicio \( \mu \), el número de clientes en la cola crece significativamente.

    \item \textbf{Probabilidad de Pérdida de Clientes:}  
    En sistemas con capacidad finita o que utilizan técnicas de abandono, la probabilidad de que un cliente sea rechazado o pierda el servicio debido a la falta de espacio en la cola o los servidores es un cálculo importante. En sistemas de colas con pérdida, esta probabilidad depende de la capacidad del sistema y de las tasas de llegada y servicio.
\end{itemize}


\subsection{Simulación de Sistemas de Colas}
\subsubsection{Técnicas de Simulación}
La simulación de sistemas de colas es una herramienta fundamental cuando los métodos analíticos no son viables o cuando se desea obtener una estimación más precisa del comportamiento de un sistema en situaciones complejas. Existen diversas técnicas de simulación utilizadas para modelar y analizar los sistemas de colas, cada una con sus características y aplicaciones específicas.

En esta subsección se describen las principales técnicas utilizadas en la simulación de sistemas de colas:

\begin{itemize}
    \item \textbf{Simulación de Monte Carlo:}  
    La \textit{simulación de Monte Carlo} es un enfoque basado en la generación de números aleatorios para modelar y analizar sistemas estocásticos. Esta técnica se utiliza para obtener estimaciones de variables de interés mediante la repetición de simulaciones del sistema bajo diferentes condiciones. En el contexto de las colas, se generan secuencias de llegadas y tiempos de servicio, y se simula el comportamiento del sistema en función de estos parámetros. La principal ventaja de esta técnica es su capacidad para manejar sistemas con configuraciones complejas, donde las fórmulas analíticas no están disponibles o son difíciles de aplicar.

    En un sistema de colas M/M/1, por ejemplo, se generan números aleatorios para simular los tiempos entre llegadas (según una distribución exponencial con parámetro \( \lambda \)) y los tiempos de servicio (según una distribución exponencial con parámetro \( \mu \)). Luego, se simula el comportamiento del sistema, manteniendo un registro de los tiempos de espera, el número de clientes en el sistema, y otros indicadores de rendimiento.

    \item \textbf{Simulación de Eventos Discretos:}  
    La \textit{simulación de eventos discretos} (Discrete Event Simulation, DES) es una de las técnicas más utilizadas en la simulación de sistemas de colas. En este enfoque, el tiempo se modela como un proceso discreto que avanza de evento en evento, es decir, el reloj de simulación avanza solo cuando ocurre un evento significativo, como una llegada de cliente, el inicio de un servicio o la finalización de un servicio. Los eventos se procesan en orden cronológico, lo que permite una simulación más eficiente que el avance continuo del tiempo.

    La simulación de eventos discretos se basa en una lista de eventos futuros, que se actualiza constantemente a medida que ocurren los eventos en el sistema. Cada evento modifica el estado del sistema y puede desencadenar nuevos eventos. En un sistema de colas, los eventos incluyen la llegada de nuevos clientes, el inicio y la finalización del servicio, y el abandono de clientes si el sistema tiene capacidad limitada.

    \item \textbf{Métodos de Generación de Números Aleatorios:}  
    En la simulación de sistemas de colas, es fundamental generar números aleatorios que sigan distribuciones específicas, como la distribución exponencial para los tiempos de llegada y servicio. Existen diferentes métodos para generar estos números aleatorios:
    
    \begin{itemize}
        \item \textbf{Método de Transformada Inversa:}  
        El método de \textit{transformada inversa} es uno de los métodos más comunes para generar números aleatorios que sigan una distribución específica. Para generar un número aleatorio \( U \) uniformemente distribuido en el intervalo \([0, 1]\), se utiliza la inversa de la función de distribución acumulada (CDF) de la distribución deseada. Por ejemplo, para obtener un número aleatorio con distribución exponencial, se aplica la fórmula:
        \[
        T = -\frac{\ln(1-U)}{\lambda},
        \]
        donde \( U \) es un número aleatorio generado uniformemente y \( \lambda \) es el parámetro de la tasa de llegada o servicio.

        \item \textbf{Método de Aceptación-Rechazo:}  
        El \textit{método de aceptación-rechazo} se utiliza cuando no se puede calcular la inversa de la función de distribución acumulada directamente. Este método genera candidatos aleatorios a partir de una distribución de fácil manejo y luego decide si se acepta o se rechaza el valor generado según una condición de probabilidad.

        \item \textbf{Generadores Pseudoaleatorios:}  
        Los generadores pseudoaleatorios son algoritmos que producen secuencias de números que se comportan como si fueran aleatorios. Estos generadores son fundamentales para la simulación, ya que permiten producir grandes volúmenes de números aleatorios de manera eficiente. Algunos de los algoritmos más utilizados incluyen el generador de congruencia lineal y el generador de Mersenne Twister.
    \end{itemize}
    
    \item \textbf{Criterios de Parada y Análisis de Resultados:}  
    La simulación de un sistema de colas debe ejecutarse hasta que los resultados obtenidos sean estadísticamente significativos. Esto requiere el uso de criterios de paro adecuados, como un número predeterminado de repeticiones de simulación o un tiempo de simulación suficientemente largo para asegurar la convergencia de los resultados.

    Después de ejecutar la simulación, los resultados deben analizarse cuidadosamente. Los parámetros de rendimiento, como el tiempo de espera promedio, el número de clientes en el sistema y la utilización del servidor, se estiman mediante medias y varianzas a partir de los datos de simulación. Para mejorar la precisión, se pueden utilizar técnicas estadísticas como intervalos de confianza o el método de \textit{bootstrap} para la estimación de la distribución de los parámetros.

\end{itemize}

\subsubsection{Simulación Discreta de Eventos}
La simulación discreta de eventos (DES) modela el comportamiento de un sistema de colas haciendo avanzar el reloj de simulación de un evento relevante al siguiente, sin iterar sobre cada instante de tiempo. Esta técnica permite representar con precisión las dinámicas de llegada, servicio y salida de clientes, y recoger estadísticas de desempeño de forma eficiente.

\begin{itemize}
    \item \textbf{Componentes principales:}
    \begin{itemize}
        \item \emph{Reloj de simulación} \(t\): almacena el tiempo actual.
        \item \emph{Lista de eventos futuros}: conjunto ordenado de pares \((t_i,\,\text{evento}_i)\) que indica el tiempo de ocurrencia de cada evento pendiente.
        \item \emph{Estado del sistema}: número de clientes en cola y en servicio, estado de cada servidor.
        \item \emph{Contadores estadísticos}: acumuladores para tiempos de espera, conteo de llegadas, ocupación de servidores, etc.
    \end{itemize}

    \item \textbf{Algoritmo de avance de evento:}
    \begin{enumerate}
        \item \emph{Inicialización}: \(t\gets0\); estado inicial (cola vacía, servidores libres); programar llegada inicial.
        \item \emph{Selección de evento}: extraer el evento con menor \(t_i\) de la lista.
        \item \emph{Avance de reloj}: \(t \gets t_i\).
        \item \emph{Procesamiento}: según el tipo de evento (llegada, inicio/fin de servicio), actualizar el estado, generar nuevos eventos (p. ej. siguiente llegada, fin de servicio).
        \item \emph{Registro}: antes o después de cada evento, actualizar los contadores de tiempo ocupado, longitud de cola, etc.
        \item \emph{Repetición}: volver al paso 2 hasta cumplir el criterio de parada.
    \end{enumerate}

    \item \textbf{Manejo de la lista de eventos}:  
    Para garantizar eficiencia \(O(\log N)\) en inserción y extracción, se utiliza típicamente una \emph{cola de prioridad} (heap) ordenada por tiempo de ocurrencia.

    \item \textbf{Recopilación de métricas}:  
    \begin{itemize}
        \item \emph{Tiempo promedio en cola} y en sistema: integrales de la longitud de la cola y de la ocupación de servidor sobre \(t\).
        \item \emph{Distribución empírica}: histogramas de tiempos de espera, conteos de número de clientes.
        \item \emph{Intervalos de confianza}: a partir de múltiples réplicas independientes, calcular medias y varianzas.
    \end{itemize}

    \item \textbf{Criterios de parada y calentamiento}:  
    \begin{itemize}
        \item \emph{Período inicial de calentamiento}: descartar muestras hasta alcanzar estado cerca de estacionario.
        \item \emph{Duración total}: basarse en número de eventos, tiempo simulado o convergencia de métricas (error relativo).
    \end{itemize}

    \item \textbf{Verificación y validación}:  
    \begin{itemize}
        \item \emph{Pruebas de regresión}: comparar resultados con soluciones analíticas (por ejemplo M/M/1).
        \item \emph{Pruebas de consistencia}: variar la semilla del generador y comprobar reproducibilidad estadística.
    \end{itemize}
\end{itemize}

%---------------------------------------------------------------------------------
% Descr. Problema ------------------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Descripción y Justificación del Problema a Resolver}\label{sec:descr}

% Puedes colocar aquí subsecciones adicionales para otras simulaciones si lo deseas
\subsection{Contexto del Problema}
La teoría de colas constituye una herramienta fundamental en el análisis y optimización de sistemas donde los recursos limitados deben atender demandas aleatorias. En el ámbito de la ingeniería de sistemas y telecomunicaciones, la validación de modelos teóricos mediante simulación computacional es esencial para garantizar su aplicabilidad en entornos reales donde los supuestos matemáticos pueden no cumplirse de manera estricta.

\subsection{Problema Central}
El presente trabajo aborda la validación, restructuración y extensión de simuladores de sistemas de colas, con el objetivo de verificar la correspondencia entre resultados teóricos y empíricos en diferentes configuraciones de sistemas de espera. Específicamente, se busca resolver los siguientes desafíos:

\subsubsection{Validación del Modelo Base M/M/1}
Verificar que el simulador proporcionado reproduzca fielmente el comportamiento del sistema M/M/1 teórico, garantizando:
\begin{itemize}
    \item Reproducibilidad de resultados mediante el uso controlado de generadores de números aleatorios
    \item Validación de métricas fundamentales:
    \begin{itemize}
        \item Utilización del servidor
        \item Tiempos de espera
        \item Longitud de colas
    \end{itemize}
\end{itemize}

\subsubsection{Restructuración Arquitectónica}
Implementar una arquitectura modular basada en los seis módulos fundamentales propuestos por Ortiz T.:
\begin{itemize}
    \item Separación clara de responsabilidades:
    \begin{itemize}
        \item Inicialización
        \item Manejo del tiempo
        \item Procesamiento de eventos
        \item Generación de variables aleatorias
        \item Actualización de estadísticas
        \item Generación de reportes
    \end{itemize}
    \item Beneficios:
    \begin{itemize}
        \item Facilita el mantenimiento
        \item Mejora la extensibilidad
        \item Permite la reutilización del código
    \end{itemize}
\end{itemize}

\subsubsection{Extensión a Modelos Multiservidor (Erlang B y C)}
Adaptar el simulador base para evaluar sistemas M/M/m:
\begin{itemize}
    \item Implementación de modelos:
    \begin{itemize}
        \item Erlang B (sistema sin cola con bloqueo)
        \item Erlang C (sistema con cola infinita)
    \end{itemize}
    \item Aplicaciones:
    \begin{itemize}
        \item Análisis de escenarios realistas con múltiples recursos en paralelo
        \item Cálculo de probabilidades de bloqueo y espera
        \item Diseño de centros de llamadas y sistemas de telecomunicaciones
    \end{itemize}
\end{itemize}

\subsubsection{Implementación de Modelo Discreto Geo/Geo/m/N}
Desarrollar un simulador completamente nuevo para sistemas de tiempo discreto:
\begin{itemize}
    \item Características:
    \begin{itemize}
        \item Llegadas y servicios con distribuciones geométricas
        \item Eventos en slots de tiempo fijos
    \end{itemize}
    \item Requerimientos:
    \begin{itemize}
        \item Implementación del algoritmo teórico de Robertazzi
        \item Validación de resultados
    \end{itemize}
    \item Aplicaciones:
    \begin{itemize}
        \item Sistemas digitales
        \item Redes de datos
    \end{itemize}
\end{itemize}

\subsection{Justificación del Problema}
\subsubsection{Relevancia Académica}
La simulación de sistemas de colas representa un pilar fundamental en la formación de ingenieros de sistemas, proporcionando:
\begin{itemize}
    \item Comprensión profunda de la traducción de modelos matemáticos a implementaciones computacionales
    \item Análisis de cómo las limitaciones teóricas afectan la aplicabilidad práctica
\end{itemize}

\subsubsection{Relevancia Práctica}
Los sistemas de colas modelados tienen aplicaciones directas en:
\begin{itemize}
    \item \textbf{Telecomunicaciones}:
    \begin{itemize}
        \item Dimensionamiento de redes
        \item Gestión de tráfico
    \end{itemize}
    \item \textbf{Sistemas de información}:
    \begin{itemize}
        \item Análisis de rendimiento de servidores
        \item Optimización de bases de datos
    \end{itemize}
    \item \textbf{Servicios}:
    \begin{itemize}
        \item Optimización de centros de atención al cliente
        \item Mejora de procesos de manufactura
    \end{itemize}
\end{itemize}

%---------------------------------------------------------------------------------
% Diseño solución ------------------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Diseño de la solución} \label{sec:disSol}

\subsection{Fases de la Simulación}

Para garantizar que el incremento en la complejidad de los sistemas estudiados fuese gradual y comprensible, el desarrollo y análisis de la simulación se organizará en tres fases:

\subsubsection{Fase 1: Modelo Base - Sistema M/M/1}

Se inicia con un sistema de colas con un único servidor, una cola de tamaño N y tiempos de llegada y servicio modelados mediante distribuciones exponenciales. En esta sección se analizan métricas fundamentales como:

\begin{itemize}
    \item \textbf{Utilización del servidor}: Proporción de tiempo que el servidor está ocupado
    \item \textbf{Longitud promedio de la cola}: Número esperado de clientes esperando en la cola
    \item \textbf{Tiempo promedio de espera}: Tiempo que un cliente pasa en el sistema antes de ser atendido
\end{itemize}

Este modelo funciona como base para extender la simulación hacia configuraciones más complejas, permitiendo establecer una arquitectura de simulación y diferentes módulos que se mantienen durante todas las simulaciones.

\subsubsection{Fase 2: Extensión a M/M/m (Erlang B y C)}

Al modelo base M/M/1 se le incorpora la posibilidad de múltiples servidores ($m$), obteniendo así un sistema M/M/m. Esta extensión incluye dos variantes importantes:

\begin{itemize}
    \item \textbf{Erlang B}: Sistema sin cola de espera, donde los clientes son rechazados si todos los servidores están ocupados
    \item \textbf{Erlang C}: Sistema con cola de espera ilimitada
\end{itemize}

Para el caso del cálculo de la probabilidad de bloqueo (Erlang B), el sistema mantiene los tiempos de llegada y servicio modelados con distribuciones exponenciales, así como la atención de $m$ servidores; pero en este caso no se tiene cola, permitiendo simular los bloqueos.

A las métricas del modelo M/M/1 se añaden las siguientes:
\begin{itemize}
    \item Probabilidad de bloqueo (Erlang B)
    \item Probabilidad de espera (Erlang C)
\end{itemize}

\subsubsection{Fase 3: Modelo Geo/Geo/m/N (Tiempo Discreto)}

En numerosos sistemas reales, especialmente en redes de comunicaciones y sistemas digitales, el tiempo evoluciona de manera discreta en lugar de continua. Por esta razón, se implementa un modelo Geo/Geo/m/N que opera en slots de tiempo discretos, donde:

\begin{itemize}
    \item Las llegadas de clientes siguen una distribución geométrica (equivalente discreta de la exponencial)
    \item Los tiempos de servicio también siguen una distribución geométrica  
    \item Hay $m$ servidores en paralelo
    \item El sistema tiene una capacidad máxima de $N$ clientes
\end{itemize}

En este modelo, cada slot de tiempo representa una unidad temporal discreta durante la cual pueden ocurrir llegadas y salidas de clientes. La probabilidad de llegada en cada slot es $p$, y la probabilidad de que un cliente termine su servicio en cada slot es $s$.

Este enfoque es particularmente útil para modelar sistemas de telecomunicaciones, redes de datos, y otros sistemas donde los eventos ocurren en intervalos de tiempo fijos y discretos.

Cada una de estas fases está diseñada de manera modular, permitiendo la evolución progresiva de la simulación sin afectar el código base. Esto facilitará la implementación y comparación de los distintos modelos, asegurando que la simulación sea flexible y adaptable a diferentes configuraciones.

\subsection{Metodología y Herramientas}

Para el desarrollo de las simulaciones se emplea el lenguaje de programación C++. La selección de herramientas específicas varía según la fase:

\begin{itemize}
    \item \textbf{Fases 1 y 2 (Modelos continuos)}: Se utiliza la librería \texttt{lcgrand.cpp} para la generación de tiempos de llegada y servicio, basándose en el teorema fundamental de la simulación
    \item \textbf{Fase 3 (Modelo discreto)}: Se implementa un simulador de tiempo discreto que opera por slots
\end{itemize}

\subsection{Métricas de Evaluación}

Para la validación de las simulaciones y estudio de los modelos se utilizarán las siguientes métricas de evaluación:

\begin{itemize}
    \item \textbf{Tiempo promedio de espera en la cola}: $W_q$
    \item \textbf{Tiempo promedio de espera en el sistema}: $W$
    \item \textbf{Utilización de los servidores}: $\rho$
    \item \textbf{Número promedio de clientes en la cola}: $L_q$
    \item \textbf{Número promedio de clientes en el sistema}: $L$
    \item \textbf{Probabilidad de Bloqueo (Erlang B)}: $P_b$
    \item \textbf{Probabilidad de Espera (Erlang C)}: $P_w$
    \item \textbf{Throughput del sistema}: $\gamma$ (específico para modelo Geo/Geo)
\end{itemize}

Estas métricas obtenidas a partir de la simulación se comparan con los valores teóricos esperados, para calificar la calidad de las simulaciones, así como para identificar deficiencias en las diferentes implementaciones.

\subsection{Arquitectura del Sistema - Modelo SAO}

Para el desarrollo de las simulaciones de los diferentes sistemas, se sigue el modelo SAO, donde cada simulación se estructura en tres módulos principales:

\subsubsection{Sistema (S)}

El sistema es una entidad que se desea estudiar de forma aislada, representado por el sistema de colas que se está modelando. Dependiendo de la fase, este sistema será:

\begin{itemize}
    \item \textbf{Fase 1}: Sistema M/M/1 con una cola
    \item \textbf{Fase 2}: Sistema M/M/m con múltiples servidores  
    \item \textbf{Fase 3}: Sistema Geo/Geo/m/N con tiempo discreto basado en slots
\end{itemize}

\subsubsection{Ambiente (A)}

Es el entorno dentro del cual se encuentra inmerso el sistema, representado por las condiciones externas de los sistemas de colas que afectan su comportamiento:

\begin{itemize}
    \item \textbf{Parámetros de entrada}:
    \begin{itemize}
        \item Para M/M/1 y M/M/m: tasas de llegada ($\lambda$) y servicio ($\mu$), número de servidores ($m$)
        \item Para Geo/Geo/m/N: probabilidad de llegada ($p$), probabilidad de servicio ($s$), número de servidores ($m$), capacidad máxima ($N$)
    \end{itemize}
    \item \textbf{Condiciones iniciales}:
    \begin{itemize}
        \item Para modelos continuos: tiempo de simulación y número de clientes a procesar
        \item Para modelo discreto: número de slots de tiempo a simular
    \end{itemize}
    \item \textbf{Distribuciones de probabilidad}: Definen el comportamiento de las llegadas y servicios del sistema
\end{itemize}

\subsubsection{Observatorio (O)}

Este módulo se encarga de medir, cuantificar y observar el desempeño del sistema dentro del ambiente. Es responsable de:

\begin{itemize}
    \item Recolectar los datos de la simulación en cada fase
    \item Generar los reportes de resultados
    \item Comparar los resultados teóricos con los empíricos
\end{itemize}

\subsection{Implementación de la Arquitectura}

Para implementar la arquitectura SAO, se desarrollan los siguientes módulos:

\subsection{Módulo 1: Inicialización del Sistema}
\begin{algorithm}[H]
\caption{Inicialización del Sistema}
\begin{algorithmic}[1]
\REQUIRE tipo\_modelo, parámetros
\STATE \textbf{Inicializar variables según modelo:}
\IF{tipo\_modelo = "M/M/1"}
    \STATE $\lambda \gets$ parámetros.tasa\_llegada
    \STATE $\mu \gets$ parámetros.tasa\_servicio
    \STATE estado\_servidor $\gets$ LIBRE
    \STATE num\_en\_cola $\gets$ 0
\ELSIF{tipo\_modelo = "M/M/m"}
    \STATE $\lambda \gets$ parámetros.tasa\_llegada
    \STATE $\mu \gets$ parámetros.tasa\_servicio
    \STATE $m \gets$ parámetros.num\_servidores
    \STATE modo $\gets$ parámetros.modo\_erlang \COMMENT{B o C}
    \STATE capacidad $\gets$ (modo = ERLANG\_B) ? $m$ : parámetros.$N$
\ELSE
    \STATE \textbf{Geom/Geom/m/N}
    \STATE $p \gets$ parámetros.prob\_llegada
    \STATE $s \gets$ parámetros.prob\_servicio
    \STATE $m \gets$ parámetros.num\_servidores
    \STATE $N \gets$ parámetros.capacidad\_maxima
    \STATE estado\_actual $\gets$ 0
    \STATE tiempo\_en\_estado[0..N] $\gets$ 0
\ENDIF
\STATE tiempo\_simulacion $\gets$ 0
\STATE InicializarContadoresEstadísticos()
\STATE ProgramarPrimerEvento()
\end{algorithmic}
\end{algorithm}

\textbf{Descripción:} Este módulo prepara el sistema según el modelo seleccionado, inicializando las variables de estado y parámetros fundamentales. Configura las condiciones iniciales para la simulación.

\subsection{Módulo 2: Manejo del Tiempo-Espacio}

\begin{algorithm}[H]
\caption{Manejo del Tiempo Continuo (M/M)}
\begin{algorithmic}[1]
\STATE min\_tiempo $\gets \infty$
\STATE siguiente\_evento $\gets$ NULL
\FOR{cada evento en lista\_eventos}
    \IF{evento.tiempo $<$ min\_tiempo}
        \STATE min\_tiempo $\gets$ evento.tiempo
        \STATE siguiente\_evento $\gets$ evento
    \ENDIF
\ENDFOR
\STATE tiempo\_simulacion $\gets$ min\_tiempo
\RETURN siguiente\_evento
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Manejo del Tiempo Discreto (Geom/Geom)}
\begin{algorithmic}[1]
\STATE slot\_actual $\gets$ slot\_actual + 1
\STATE ActualizarEstadísticasTiempoEstado()
\RETURN slot\_actual
\end{algorithmic}
\end{algorithm}

\textbf{Descripción:} Estos algoritmos gestionan el avance del tiempo de simulación. La versión continua determina el próximo evento a procesar, mientras que la discreta avanza en unidades de slots.

\subsection{Módulo 3: Procesamiento de Eventos}

\begin{algorithm}[H]
\caption{Evento de Llegada (M/M/m)}
\begin{algorithmic}[1]
\STATE ProgramarSiguienteLlegada(tiempo\_simulacion + Exponencial($\lambda$))
\IF{servidores\_ocupados $< m$}
    \STATE servidores\_ocupados $\gets$ servidores\_ocupados + 1
    \STATE servidor\_asignado $\gets$ AsignarServidorLibre()
    \STATE ProgramarSalida(servidor\_asignado, tiempo\_simulacion + Exponencial($\mu$))
\ELSE
    \IF{modo = ERLANG\_C $\land$ num\_en\_cola $<$ capacidad\_cola}
        \STATE num\_en\_cola $\gets$ num\_en\_cola + 1
        \STATE clientes\_que\_esperaron $\gets$ clientes\_que\_esperaron + 1
    \ELSE
        \STATE clientes\_bloqueados $\gets$ clientes\_bloqueados + 1
    \ENDIF
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Procesamiento de Slot (Geom/Geom/m/N)}
\begin{algorithmic}[1]
\STATE tiempo\_en\_estado[estado\_actual] $\gets$ tiempo\_en\_estado[estado\_actual] + 1
\STATE llegadas $\gets$ Bernoulli($p$)
\STATE salidas $\gets$ Binomial($\min$(estado\_actual, $m$), $s$)
\STATE estado\_actual $\gets \max$(0, estado\_actual $-$ salidas)
\IF{llegadas = 1}
    \IF{estado\_actual $< N$}
        \STATE estado\_actual $\gets$ estado\_actual + 1
        \STATE clientes\_llegados $\gets$ clientes\_llegados + 1
    \ELSE
        \STATE clientes\_perdidos $\gets$ clientes\_perdidos + 1
    \ENDIF
\ENDIF
\STATE servidores\_ocupados $\gets \min$(estado\_actual, $m$)
\STATE cola\_actual $\gets \max$(0, estado\_actual $-$ $m$)
\end{algorithmic}
\end{algorithm}

\textbf{Descripción:} Estos algoritmos procesan los eventos fundamentales de llegada y servicio. El primero maneja llegadas continuas, mientras que el segundo procesa slots discretos completos.

\subsection{Módulo 4: Generación de Variables Aleatorias}

\begin{algorithm}[H]
\caption{Funciones de Generación Aleatoria}
\begin{algorithmic}[1]
    \STATE \textbf{Función} GenerarExponencial(media)
    \STATE \hspace{1em} u $\gets$ lcgrand(semilla)
    \STATE \hspace{1em} \textbf{return} $-\text{media} \times \ln(u)$

    \STATE \textbf{Función} GenerarBernoulli(p)
    \STATE \hspace{1em} u $\gets$ lcgrand(semilla)
    \STATE \hspace{1em} \textbf{return} (u < p) ? 1 : 0

    \STATE \textbf{Función} GenerarBinomial(n, p)
    \STATE \hspace{1em} éxitos $\gets$ 0
    \FOR{i $\gets$ 1 \TO n}
        \STATE \hspace{2em} éxitos $\gets$ éxitos + GenerarBernoulli(p)
    \ENDFOR
    \STATE \hspace{1em} \textbf{return} éxitos
\end{algorithmic}
\end{algorithm}

\textbf{Descripción:} Este módulo proporciona las funciones esenciales para la generación de variables aleatorias según las distribuciones requeridas por los diferentes modelos.

\subsection{Módulo 5: Generación de Reportes}

\begin{algorithm}[H]
\caption{Generación de Reportes}
\begin{algorithmic}[1]
\IF{tipo\_modelo $\in$ ["M/M/1", "M/M/m"]}
    \STATE utilización $\gets$ área\_servidores\_ocupados / tiempo\_simulacion
    \STATE $L \gets$ área\_num\_en\_sistema / tiempo\_simulacion
    \STATE $W \gets$ total\_esperas / clientes\_atendidos
    \STATE $\lambda$\_efectiva $\gets$ clientes\_atendidos / tiempo\_simulacion
    \IF{modo = ERLANG\_B}
        \STATE $P_b \gets$ clientes\_bloqueados / clientes\_llegados
    \ELSIF{modo = ERLANG\_C}
        \STATE $P_w \gets$ clientes\_que\_esperaron / clientes\_llegados
    \ENDIF
\ELSE
    \STATE \textbf{Geo/Geo/m/N}
    \FOR{$n \gets 0$ \TO $N$}
        \STATE $P_n \gets$ tiempo\_en\_estado[$n$] / total\_slots
    \ENDFOR
    \STATE $P_b \gets$ clientes\_perdidos / clientes\_llegados
    \STATE $L \gets \sum_{n=0}^N (n \times P_n)$
    \STATE $Y \gets p \times (1 - P_b)$ \COMMENT{Throughput}
    \STATE $W \gets L / Y$ \COMMENT{Ley de Little}
\ENDIF
\STATE EscribirArchivo("estadisticas.txt", métricas\_simuladas)
\STATE EscribirArchivo("comparacion\_teorica.txt", comparación)
\STATE EscribirArchivo("resumen\_resultados.txt", resumen)
\end{algorithmic}
\end{algorithm}

\textbf{Descripción:} Calcula las métricas de desempeño clave para cada modelo y genera los archivos de salida con los resultados de la simulación.

\subsection{Módulo 6: Ciclo Principal de Simulación}

\begin{algorithm}[H]
\caption{Simulador Principal (Tiempo Continuo)}
\begin{algorithmic}[1]
\STATE Inicialización(tipo\_modelo, parámetros)
\WHILE{clientes\_procesados $<$ num\_clientes\_requeridos}
    \STATE evento $\gets$ ManejoTiempoContinuo()
    \STATE ActualizarEstadísticasPromedio()
    \IF{evento.tipo = LLEGADA}
        \STATE EventoLlegada()
    \ELSE
        \STATE EventoSalida(evento.servidor)
    \ENDIF
\ENDWHILE
\STATE GenerarReportes()
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Simulador Principal (Tiempo Discreto)}
\begin{algorithmic}[1]
\STATE Inicialización("Geom/Geom/m/N", parámetros)
\FOR{slot $\gets 1$ \TO num\_slots}
    \STATE ProcesarSlotGeomGeom()
\ENDFOR
\STATE GenerarReportes()
\end{algorithmic}
\end{algorithm}

\textbf{Descripción:} Estos algoritmos representan los bucles principales de simulación para los modelos de tiempo continuo y discreto respectivamente, coordinando todos los módulos anteriores.


\subsection{Modelos Específicos}
\subsubsection{Modelo M/M/1}

El modelo M/M/1 es el caso más básico en la teoría de colas y representa un sistema en el que los clientes llegan de forma aleatoria (siguiendo alguna distribución) y son atendidos por un solo servidor. En este modelo, los tiempos entre llegadas siguen una distribución exponencial con tasa $\lambda$, lo que implica que los clientes llegan según un proceso de Poisson. Así mismo, el tiempo de servicio también es exponencial con una tasa $\mu$, lo que indica que los clientes son atendidos con una duración media de $1/\mu$ minutos.

Una característica clave de este sistema es que se tiene una cola de capacidad N, la cual sigue un comportamiento de atención FIFO (First In, First Out), lo que significa que los clientes son atendidos en el orden en que llegan. Como en todas las simulaciones que se tratan aquí, estas son simulaciones de eventos discretos, donde el tiempo avanza en función a estos mismos y no de manera continua. En este caso, los eventos que se manejan son:

\begin{itemize}
    \item \textbf{Evento de llegada}: Simula la situación en donde un nuevo cliente ingresa al sistema.
    \item \textbf{Evento de salida}: Simula que un cliente finaliza su servicio y abandona el sistema.
\end{itemize}

% Insertar Figura MM1FLujo

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{images/flujos/MM1FLujo.png}
    \caption{Diagrama de flujo del sistema M/M/1}
    \label{fig:mm1_flujo}
\end{figure}

Dado que el sistema no rechaza clientes, la cantidad de usuarios en espera puede crecer indefinidamente si la tasa de llegada es mayor que la tasa de servicio ($\lambda > \mu$). Para que el sistema sea estable, se debe cumplir que $\lambda < \mu$, lo que garantiza que la utilización del servidor ($\rho = \lambda/\mu$) se mantenga por debajo del 100\%.

Las fórmulas clave del modelo son:
\begin{align}
\rho &= \frac{\lambda}{\mu} \quad \text{(Utilización)} \\
L_q &= \frac{\rho^2}{1-\rho} \quad \text{(Clientes en cola)} \\
W_q &= \frac{\lambda}{\mu(\mu - \lambda)} \quad \text{(Tiempo en cola)} \\
L &= \frac{\rho}{1-\rho} \quad \text{(Clientes en sistema)}
\end{align}

\paragraph{Eventos}

\subparagraph{Llegada}
La llegada de un cliente al sistema M/M/1 se simula generando un tiempo de llegada aleatorio basado en una distribución exponencial con tasa $\lambda$. Si el servidor está libre, el cliente comienza su servicio inmediatamente; si no, se coloca en la cola.
% Aquí se incluirá la Figura 4. Evento llegada sistema M/M/1
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/flujos/MM1Llegada.png}
    \caption{Evento de llegada en el sistema M/M/1}
    \label{fig:mm1_llegada}
\end{figure}


\subparagraph{Salida}
Cuando un cliente finaliza su servicio, se genera un evento de salida que libera al servidor. Si hay clientes en la cola, el siguiente cliente comienza su servicio inmediatamente; si no, el servidor queda libre.
% Aquí se incluirá la Figura 5. Evento salida sistema M/M/1
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{images/flujos/MM1Salida.png}
    \caption{Evento de salida en el sistema M/M/1}
    \label{fig:mm1_salida}
\end{figure}

\subsubsection{Modelo M/M/m}

El modelo M/M/m representa una extensión del sistema de colas M/M/1, en la que hay $m$ servidores en paralelo en lugar de solo uno. Este sistema sigue teniendo llegadas de clientes siguiendo un proceso de Poisson con tasa $\lambda$ y tiempos de servicio exponenciales con tasa $\mu$. Sin embargo, la diferencia clave es que hay múltiples servidores disponibles para atender a los clientes simultáneamente.

% Insertar Figura 5. Flujo M/M/m
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{images/flujos/ErlangFujo.png}
    \caption{Diagrama de flujo del sistema M/M/m}
    \label{fig:mm_m_flujo}
\end{figure}

En este caso, los eventos que se manejan son:

\begin{itemize}
    \item \textbf{Evento de llegada}: Simula la situación en donde un nuevo cliente ingresa al sistema.
% Insertar Figura 5. Evento llegada ErlandLlegada
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{images/flujos/ErlangLlegada.png}
    \caption{Evento de llegada en el sistema M/M/m}
    \label{fig:mm_m_llegada}
\end{figure}

    \item \textbf{Evento de salida por servidor}: Simula que un cliente finaliza su servicio y abandona uno de los $m$ servidores y posteriormente el sistema.

% Insertar Figura 6. Evento salida ErlandSalida
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{images/flujos/ErlangSalida.png}
    \caption{Evento de salida en el sistema M/M/m}
    \label{fig:mm_m_salida}
\end{figure}
\end{itemize}

Las métricas principales adicionales son:

\textbf{Erlang B:} En el simulador, cuando un cliente llega y todos los servidores están ocupados, y si el sistema está configurado en modo Erlang B (sin cola), este cliente se cuenta como \textit{bloqueado}. La probabilidad empírica de bloqueo se estima como:
    \[
        \hat{B}_{sim} = \frac{\text{tiempo donde todos los m servidores están ocupados}}{\text{Tiempo total}}
    \]
\textbf{Erlang C:} En el simulador, si todos los servidores están ocupados y el modo es Erlang C, el cliente se coloca en cola. Se puede estimar la probabilidad empírica de espera como:
    \[
        \hat{C}_{tiempo} = \frac{\text{Tiempo acumulado con todos los servidores ocupados}}{\text{Tiempo total de simulación}}
    \]
Cada métrica se actualiza de forma acumulativa a lo largo de la simulación usando contadores y variables auxiliares.

\subsubsection{Modelo Geo/Geo/m/N}

El modelo Geo/Geo/m/N representa un sistema de colas de tiempo discreto que es el análogo discreto del sistema M/M/m/N de tiempo continuo. Este modelo se basa en el trabajo presentado en la sección 6.4 "The Geom/Geom/m/N Queueing System" del libro "Computer Networks and Systems: Queueing Theory and Performance Evaluation Third Edition" de Thomas G. Robertazzi.

\paragraph{Características del Sistema}

El sistema Geo/Geo/m/N se caracteriza por:

\begin{itemize}
    \item \textbf{Tiempo discreto}: La simulación opera en slots de tiempo fijos
    \item \textbf{Llegadas geométricas}: En cada slot, llega un cliente con probabilidad $p$ (proceso de Bernoulli)
    \item \textbf{Servicios geométricos}: En cada slot, cada servidor ocupado completa el servicio con probabilidad $s$
    \item \textbf{Múltiples servidores}: Hasta $m$ clientes pueden ser atendidos simultáneamente
    \item \textbf{Capacidad finita}: El sistema puede contener máximo $N$ clientes (incluyendo los en servicio)
    \item \textbf{Política FIFO}: Los clientes son atendidos en orden de llegada
    \item \textbf{Bloqueo}: Si el sistema está lleno ($N$ clientes), las nuevas llegadas se pierden
\end{itemize}

\paragraph{Diferencias con Modelos Continuos}

A diferencia de los modelos M/M/1 y M/M/m de tiempo continuo, el modelo Geo/Geo/m/N presenta las siguientes características distintivas:

\begin{itemize}
    \item \textbf{Avance por slots}: El tiempo avanza en unidades discretas fijas
    \item \textbf{Eventos simultáneos}: En un mismo slot pueden ocurrir múltiples llegadas y salidas
    \item \textbf{Distribuciones discretas}: Las llegadas siguen distribución geométrica (análogo discreto de la exponencial)
    \item \textbf{Capacidad limitada}: El sistema tiene un número máximo $N$ de clientes
    \item \textbf{Sin eventos programados}: No se mantiene una lista de eventos futuros
\end{itemize}

\paragraph{Parámetros del Sistema}

\begin{itemize}
    \item $N$: Capacidad máxima del sistema (número total de clientes que puede contener)
    \item $m$: Número de servidores (máximo número de clientes que pueden ser atendidos simultáneamente)
    \item $p$: Probabilidad de llegada de un cliente en un slot ($0 \leq p \leq 1$)
    \item $s$: Probabilidad de que un cliente termine su servicio en un slot ($0 \leq s \leq 1$)
    \item $num\_slots$: Número de slots de tiempo para la simulación
\end{itemize}

% Insertar Figura 7. Flujo Geo/Geo/m/N
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{images/flujos/GeoFlujo.png}
    \caption{Diagrama de flujo del sistema Geo/Geo/m/N}
    \label{fig:geo_geo_flujo}
\end{figure}

% Insertar Figura 8. Slots Geo/Geo/m/N
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{images/flujos/GeoSlot.png}
    \caption{Slots de tiempo en el sistema Geo/Geo/m/N}
    \label{fig:geo_geo_slots}
\end{figure}
\paragraph{Métricas Específicas}

Para este modelo se calculan métricas específicas:

\begin{itemize}
    \item \textbf{Distribución de probabilidad}: $\hat{P}_n = \frac{\text{tiempo en estado } n}{\text{num\_slots}}$
    \item \textbf{Probabilidad de bloqueo}: $\hat{p}_b = \frac{\text{clientes\_perdidos}}{\text{clientes\_llegados}}$
    \item \textbf{Throughput}: $\gamma = \frac{\text{clientes\_llegados - clientes\_perdidos}}{\text{num\_slots}}$
    \item \textbf{Utilización}: $U = \frac{\text{slots donde sistema no vacío}}{\text{num\_slots}} \times 100\%$
\end{itemize}

\paragraph{Algoritmo Teórico de Robertazzi}

El cálculo de las probabilidades teóricas se realiza mediante el algoritmo recursivo descrito por Robertazzi, que se basa en la relación de recurrencia para calcular las probabilidades de estado del sistema Geo/Geo/m/N. El algoritmo es el siguiente:

\begin{algorithm}[H]
\caption{Algoritmo de Robertazzi para Geo/Geo/m/N}
\begin{algorithmic}[1]
\STATE $P_0 \leftarrow \frac{1}{\sum_{k=0}^{m} \frac{(p \cdot m)^k}{k!}}$ \COMMENT{Probabilidad de que el sistema esté vacío}
\FOR{$n = 1$ TO $N$}
    \IF{$n < m$}
        \STATE $P_n \leftarrow P_0 \cdot \frac{(p \cdot m)^n}{n!}$
    \ELSE
        \STATE $P_n \leftarrow P_0 \cdot \frac{(p \cdot m)^m}{m!} \cdot \left(\frac{p}{m}\right)^{n-m}$
    \ENDIF
\ENDFOR
\STATE $P_b \leftarrow P_N$ \COMMENT{Probabilidad de bloqueo}
\STATE $P_w \leftarrow \frac{P_b}{1 - P_b}$ \COMMENT{Probabilidad de espera}
\end{algorithmic}
\end{algorithm}

\subsection{Criterios de Validación}

Para validar la correctitud de las simulaciones, se compararán los resultados simulados con los valores teóricos.


%---------------------------------------------------------------------------------
% Código Fuente ------------------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Código Fuente}\label{sec:cod}

El código fuente completo se encuentra adjunto como Taller2.zip
o en el siguiente repositorio de GitHub:

\begin{center}
\url{https://github.com/JavierTarazona06/ME01_Tareas/tree/main/taller2/Code/}
\end{center}


%---------------------------------------------------------------------------------
% Manual de Usuario ------------------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Manual Usuario}\label{sec:man_u}

\subsection{M/M/1}\label{subsec:mm1_usuario}

\subsubsection{Prerequisitos}
Para la ejecución del simulador en un entorno Linux con Ubuntu, se requieren:
\begin{itemize}
    \item Conocimientos básicos de Linux y C++
    \item Conexión a internet para descargar g++
    \item En sistemas Windows se recomienda utilizar WSL (Windows Subsystem for Linux)
\end{itemize}

\subsubsection{Instalación de g++}
Para instalar el compilador necesario en Ubuntu/WSL:
\begin{verbatim}
sudo apt update
sudo apt install g++
\end{verbatim}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_1.png}
    \caption{Proceso de instalación de g++}
    \label{fig:instalacion_mm1}
\end{figure}

Verificación de la instalación:
\begin{verbatim}
g++ --version
\end{verbatim}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_2.png}
    \caption{Verificación de la versión de g++}
    \label{fig:version_mm1}
\end{figure}

\subsubsection{Instalación de Ubuntu en WSL (Opcional)}
En caso de que se esté trabajando en Windows, se recomienda utilizar WSL. Para instalarlo siga los siguientes pasos:

\begin{enumerate}
    \item Verificar/Activar característica WSL

    Ir al panel de control y seleccionar ``desinstalar un programa`` en la sección de programas.

    \begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_6.png}
    \caption{Panel de Control}
    \label{fig:panel_mm1}
    \end{figure}

    A continuación, a la izquierda encontrará ``Activar o desactivar las características de Windows``. Al oprimirlo, le abrirá una ventana donde debe verificar que la casilla ``Subsistema de Windows para Linux`` esté seleccionada.

    \begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_7.png}
    \caption{Características de Windows}
    \label{fig:caracteristicas_mm1}
    \end{figure}

    \item Instalación

    Vaya a Microsoft Store y busque Ubuntu, oprima la primera opción y después ``Obtener``. Una vez finalizada la descarga, abra el programa.

    \begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_8.png}
    \caption{Microsoft Store}
    \label{fig:store_mm1}
    \end{figure}

    Finalmente, siga los pasos para configurar el usuario y ejecute cualquier comando para verificar su correcto funcionamiento (puede usar el comando \texttt{ls}).

    \begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_9.png}
    \caption{Instalación exitosa de Ubuntu en WSL}
    \label{fig:instalacion_wsl_mm1}
    \end{figure}
\end{enumerate}

\subsubsection{Configuración de parámetros}
Los parámetros de simulación se configuran en el archivo \texttt{param.txt} ubicado en \texttt{taller2/code/SimulacionDeColas}. Los parámetros son:

\begin{itemize}
    \item \texttt{media\_entre\_llegadas}: Tiempo medio entre llegadas (float)
    \item \texttt{media\_atencion}: Tiempo medio de atención (float)
    \item \texttt{num\_esperas\_requerido}: Número de clientes a simular (integer)
    \item \texttt{semilla}: Semilla para el generador aleatorio (integer)
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_3.png}
    \caption{Ejemplo de archivo de parámetros}
    \label{fig:parametros_mm1}
\end{figure}

\subsubsection{Compilación y ejecución}
Proceso para compilar y ejecutar:

1. Compilación del programa:
\begin{verbatim}
g++ SistemadeColas.cpp lcgrand.cpp -o SistemadeColas
\end{verbatim}

2. Ejecución del simulador:
\begin{verbatim}
./SistemadeColas
\end{verbatim}

También puede ejecutarse con parámetros desde la línea de comandos:
\begin{verbatim}
./SistemadeColas <media_entre_llegadas> <media_atencion> <num_esperas_requerido> <semilla>
\end{verbatim}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_4.png}
    \caption{Proceso de compilación y ejecución}
    \label{fig:compilacion_mm1}
\end{figure}

\subsubsection{Resultados}
El programa genera un archivo \texttt{result.txt} con:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_5.png}
    \caption{Ejemplo de archivo de resultados}
    \label{fig:resultados_mm1}
\end{figure}

La estructura del archivo incluye primero los parámetros de entrada, como los tiempos promedio de llegada y atención, el número de clientes simulados y la semilla utilizada. Luego, muestra los resultados principales, como el tiempo promedio en cola, la utilización del servidor y métricas de desempeño. Finalmente, indica el tiempo total de simulación. Este formato permite analizar rápidamente el comportamiento del sistema y la eficiencia de los recursos.

\subsection{Erlang B y C}\label{subsec:erlang_bc}

\subsubsection{Prerequisitos}
Para la ejecución del simulador en un entorno Linux con Ubuntu, se requieren:
\begin{itemize}
    \item Conocimientos básicos de Linux y C++
    \item Conexión a internet para descargar g++
    \item En sistemas Windows se recomienda utilizar WSL (Windows Subsystem for Linux)
\end{itemize}

\subsubsection{Instalación de g++}
Para instalar el compilador necesario en Ubuntu/WSL:
\begin{verbatim}
sudo apt update
sudo apt install g++
\end{verbatim}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_1.png}
    \caption{Proceso de instalación de g++}
    \label{fig:instalacion}
\end{figure}

Verificación de la instalación:
\begin{verbatim}
g++ --version
\end{verbatim}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_2.png}
    \caption{Verificación de la versión de g++}
    \label{fig:version}
\end{figure}

\subsubsection{Instalación de Ubuntu en WSL (Opcional)}
En caso de que se esté trabajando en windows hay varias alternativas para compilar y ejecutar el codigo c++. Acá presentamos una por medio de Ubuntu en WSL. Para instalarlo siga los siguientes pasos:

\begin{enumerate}
    \item Verificar/Activar característica WSL
    
    Ir al panel de control y seleccionar ``desistalar un programa`` en la sección de programas

    \begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_6.png}
    \caption{Panel de Control}
    \label{fig:version}
\end{figure}

A continuación a la izquierda encontrará ``Activar o desactivar las características de Windows`` al oprimirlo le abrirá una ventana donde debe verificar que la casilla ``Subsistema de Windows para Linux`` este seleccionada, en caso de no estarlo seleccionela

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_7.png}
    \caption{Características de Windows}
    \label{fig:version}
\end{figure}

    \item Instalación
    
    Vaya a Microsoft Store y busque Ubuntu, oprima la primera opción y despues ``Obtener``, acá se instalará. Pueden salir cuadros de dialogo para pedir permisos, oprima aceptar. Una vez finalizada la descarga abra el programa.

    \begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_8.png}
    \caption{Microsoft Store}
    \label{fig:version}
\end{figure}

Finalmente siga los pasos para configurar el usuario y ejecute cualquier comando para verificar su correcto funcionamiento (Puede ussar el comando ls).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_9.png}
    \caption{Instalación exitosa de Ubuntu en WSL}
    \label{fig:version}
\end{figure}

\end{enumerate}

\subsubsection{Configuración de parámetros}
Los parámetros de simulación se configuran en el archivo 
\texttt{param.txt} ubicado en \texttt{taller2/code/}
\texttt{SimulacionDeColasErlang}. Los parámetros son:

\begin{itemize}
    \item \texttt{media\_entre\_llegadas}: Tiempo medio entre llegadas (float)
    \item \texttt{media\_atencion}: Tiempo medio de atención (float)
    \item \texttt{num\_esperas\_requerido}: Número de esperas a simular (integer)
    \item \texttt{modo}: Tipo de modelo Erlang (0 para B, 1 para C)
    \item \texttt{num\_servidores}: Cantidad de servidores (integer)
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{images/manualUsuarioErlangBC_3.png}
    \caption{Ejemplo de archivo de parámetros}
    \label{fig:parametros}
\end{figure}

\subsubsection{Compilación y ejecución}
Proceso para compilar y ejecutar:

1. Compilación del programa:
\begin{verbatim}
g++ Sistema\ de\ Colas.cpp -o SistemaDeColas
\end{verbatim}

2. Ejecución del simulador:
\begin{verbatim}
./SistemaDeColas
\end{verbatim}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_4.png}
    \caption{Proceso de compilación y ejecución}
    \label{fig:compilacion}
\end{figure}

\subsubsection{Resultados}
El programa genera un archivo \texttt{result.txt} con:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/manualUsuarioErlangBC_5.png}
    \caption{Ejemplo de archivo de resultados}
    \label{fig:resultados}
\end{figure}

La estructura del archivo incluye primero los parámetros de entrada, como los tiempos promedio de llegada y atención, el número de clientes simulados y la configuración de servidores. Luego, muestra los resultados principales, como la probabilidad de bloqueo, el uso de cada servidor y métricas de desempeño (tiempos de espera y ocupación). Finalmente, indica el tiempo total de simulación y el número de clientes rechazados. Este formato permite analizar rápidamente el comportamiento del sistema y la eficiencia de los recursos.

% Manual de Usuario Geo Geo 

\subsection{Geo/Geo/m/N}\label{subsec:geogeo}

Este manual proporciona una guía completa para el uso del simulador de sistemas de colas tipo Geom/Geom/m/N. El simulador permite analizar el comportamiento de sistemas con:
\begin{itemize}
    \item Llegadas geométricas discretas
    \item Tiempos de servicio geométricos
    \item $m$ servidores en paralelo
    \item Capacidad limitada $N$ (incluyendo clientes en servicio y en cola)
\end{itemize}

\subsubsection{Teoría del Sistema de Colas}
Un sistema de colas Geom/Geom/m/N se caracteriza por:
\begin{itemize}
    \item \textbf{Proceso de llegada}: Geométrico con probabilidad $p$ de llegada por slot de tiempo
    \item \textbf{Proceso de servicio}: Geométrico con probabilidad $s$ de finalización de servicio por slot
    \item \textbf{Número de servidores}: $m$ servidores trabajando en paralelo
    \item \textbf{Capacidad del sistema}: Máximo $N$ clientes en el sistema
    \item \textbf{Disciplina}: FIFO (First In, First Out)
\end{itemize}

\subsubsection{Requisitos del Sistema}

\paragraph{Requisitos de Hardware}
\begin{itemize}
    \item Procesador: Cualquier procesador x86/x64 moderno
    \item Memoria RAM: Mínimo 512 MB
    \item Espacio en disco: 50 MB libres
\end{itemize}

\paragraph{Requisitos de Software}
\begin{itemize}
    \item Sistema operativo: Windows, Linux o macOS
    \item Compilador C++: GCC, Clang o Microsoft Visual C++
    \item Bibliotecas estándar de C++
\end{itemize}

\subsubsection{Instalación y Compilación}

\paragraph{Estructura de Archivos}
El programa requiere los siguientes archivos:
\begin{itemize}
    \item \texttt{simulador.cpp}: Código fuente principal
    \item \texttt{lcgrand.cpp}: Generador de números aleatorios (ubicado en \texttt{../SimulacionDeColas/})
    \item \texttt{paramGeo.txt}: Archivo de parámetros de entrada
\end{itemize}

\paragraph{Compilación}
Para compilar el programa, utilice el siguiente comando:

\begin{lstlisting}[language=bash]
g++ -o sistemaGeoGeo sistemaGeoGeo.cpp -lm
\end{lstlisting}

En sistemas Windows con MinGW:
\begin{lstlisting}[language=bash]
g++ -o sistemaGeoGeo.exe sistemaGeoGeo.cpp -lm
\end{lstlisting}

\subsubsection{Configuración de Parámetros}

\paragraph{Archivo de Parámetros (paramGeo.txt)}
Antes de ejecutar la simulación, debe crear el archivo \texttt{paramGeo.txt} con los parámetros del sistema:

\begin{lstlisting}
N m p s num_slots
\end{lstlisting}

Donde:
\begin{itemize}
    \item \texttt{N}: Capacidad máxima del sistema $(1 \leq N \leq 1000)$
    \item \texttt{m}: Número de servidores $(1 \leq m \leq 10)$
    \item \texttt{p}: Probabilidad de llegada por slot $(0 < p < 1)$
    \item \texttt{s}: Probabilidad de finalización de servicio por slot $(0 < s < 1)$
    \item \texttt{num\_slots}: Número de slots de tiempo a simular
\end{itemize}

\subsubsection{Ejemplo de Configuración}
\begin{lstlisting}
5 2 0.3 0.4 100000
\end{lstlisting}

Este ejemplo configura:
\begin{itemize}
    \item Capacidad máxima: 5 clientes
    \item Número de servidores: 2
    \item Probabilidad de llegada: 30\%
    \item Probabilidad de servicio: 40\%
    \item Duración: 100,000 slots
\end{itemize}

\subsubsection{Ejecución del Simulador}

\paragraph{Comando de Ejecución}
Una vez compilado, ejecute el programa con:

\begin{lstlisting}[language=bash]
./sistemaGeoGeo
\end{lstlisting}

En Windows:
\begin{lstlisting}[language=bash]
sistemaGeoGeo.exe
\end{lstlisting}

\paragraph{Salida en Consola}
El programa mostrará información durante la ejecución:

\begin{lstlisting}
Simulador del sistema (Geom/Geom/m):(FIFO/N/+oo)
Parametros: N=5, m=2, p=0.30, s=0.40
Numero de slots: 100000

Simulacion completada. Resultados guardados en archivos de texto.
\end{lstlisting}

\subsubsection{Archivos de Resultados}

El simulador genera tres archivos de salida:

\paragraph{estadisticas.txt}
Contiene las probabilidades de estado simuladas:
\begin{itemize}
    \item Distribución de probabilidades por estado
    \item Número total de clientes llegados
    \item Número de clientes perdidos (bloqueados)
    \item Probabilidad de bloqueo simulada
\end{itemize}

\paragraph{comparacion\_teorica.txt}
Compara los resultados simulados con los teóricos:
\begin{itemize}
    \item Probabilidades simuladas vs. teóricas por estado
    \item Diferencias absolutas entre valores
    \item Comparación de probabilidades de bloqueo
\end{itemize}

\paragraph{resumen\_resultados.txt}
Presenta un resumen ejecutivo del sistema:
\begin{itemize}
    \item Número total de slots simulados
    \item Porcentaje de utilización del sistema
    \item Número promedio de clientes en el sistema
    \item Throughput (clientes atendidos por slot)
\end{itemize}

\subsubsection{Ejemplos de Uso}

\paragraph{Ejemplo 1: Sistema Básico}

\textbf{Configuración (paramGeo.txt):}
\begin{lstlisting}
3 1 0.25 0.5 50000
\end{lstlisting}

\textbf{Interpretación:}
\begin{itemize}
    \item Sistema con capacidad para 3 clientes
    \item 1 servidor
    \item 25\% probabilidad de llegada
    \item 50\% probabilidad de servicio
\end{itemize}

\paragraph{Ejemplo 2: Sistema Multi-servidor}

\textbf{Configuración (paramGeo.txt):}
\begin{lstlisting}
10 3 0.4 0.3 200000
\end{lstlisting}

\textbf{Interpretación:}
\begin{itemize}
    \item Sistema con capacidad para 10 clientes
    \item 3 servidores en paralelo
    \item 40\% probabilidad de llegada
    \item 30\% probabilidad de servicio por servidor
\end{itemize}

\subsubsection{Solución de Problemas}

\paragraph{Errores Comunes}

\paragraph{Error: No se pudo abrir 'paramGeo.txt'}
\paragraph{Causa:} El archivo de parámetros no existe o no está en el directorio correcto.

\paragraph{Solución:} 
\begin{enumerate}
    \item Verifique que el archivo existe
    \item Confirme que está en el mismo directorio que el ejecutable
    \item Revise los permisos de lectura del archivo
\end{enumerate}

\paragraph{Error: Formato incorrecto en 'paramGeo.txt'}
\paragraph{Causa:} Los parámetros no están en el formato correcto.
% Dejar un enter
\paragraph{Solución:}
\begin{enumerate}
    \item Asegúrese de que hay exactamente 5 valores
    \item Verifique que están separados por espacios
    \item Confirme que los valores numéricos son válidos
\end{enumerate}

\paragraph{Error: No se pudieron crear archivos de salida}
\paragraph{Causa:} Problemas de permisos de escritura.
\paragraph{Solución:}
\begin{enumerate}
    \item Verifique permisos de escritura en el directorio
    \item Libere espacio en disco si es necesario
    \item Ejecute desde un directorio con permisos adecuados
\end{enumerate}

\paragraph{Optimización del Rendimiento}

\paragraph{Selección del Número de Slots}
Para obtener resultados precisos:
\begin{itemize}
    \item Use al menos 10,000 slots para sistemas simples
    \item Use 100,000 o más slots para análisis detallados
    \item Incremente si las diferencias teóricas-simuladas son grandes
\end{itemize}

%---------------------------------------------------------------------------------
% Manual técnico ------------------------------------------------------------------
%---------------------------------------------------------------------------------

\section{Manual Técnico}

\subsection{M/M/1}\label{subsec:mm1}

Simulador de un sistema de colas $(M/M/1):(FIFO/\infty)$ implementado en C++. El programa modela un sistema de colas con llegadas y servicios exponenciales, un solo servidor, capacidad infinita y disciplina FIFO.

\subsubsection{Prerequisitos}

\begin{itemize}
    \item Compilador C++ compatible con C++11 o superior
    \item Bibliotecas estándar: \texttt{stdio.h}, \texttt{stdlib.h}, \texttt{math.h}, \texttt{time.h}
    \item Generador de números aleatorios proporcionado en \texttt{lcgrand.cpp}
    \item Sistema operativo: Windows/Linux/macOS
\end{itemize}

\subsubsection{Estructura del código}

El programa sigue una estructura modular con las siguientes componentes principales:

\begin{itemize}
    \item \textbf{Variables globales}:
    \begin{itemize}
        \item Parámetros del sistema (\texttt{media\_entre\_llegadas}, \texttt{media\_atencion}, \texttt{num\_esperas\_requerido}, \texttt{semilla})
        \item Estado del sistema (tiempo de simulación, número de clientes en cola, estado del servidor)
        \item Estadísticas (tiempo promedio en cola, ocupación del servidor, tiempos de llegada y atención)
    \end{itemize}
    
    \item \textbf{Funciones principales}:
    \begin{itemize}
        \item \texttt{main()}: Coordina el flujo del programa
        \item \texttt{inicializar()}: Prepara el sistema para la simulación
        \item \texttt{controltiempo()}: Gestiona el avance de eventos
        \item \texttt{llegada()}, \texttt{salida()}: Procesan los eventos de llegada y salida de clientes
        \item \texttt{reportes()}: Calcula y reporta las métricas de desempeño
    \end{itemize}
    
    \item \textbf{Funciones auxiliares}:
    \begin{itemize}
        \item Generación aleatoria: \texttt{expon()}, \texttt{lcgrand()}
        \item Actualización de estadísticas: \texttt{actualizar\_estad\_prom\_tiempo()}, \texttt{actualizar\_ocupacion\_sistema()}
    \end{itemize}
\end{itemize}

\subsubsection{Parámetros de la simulación}

Los parámetros se leen del archivo \texttt{param.txt} con el formato:

\begin{verbatim}
media_entre_llegadas media_atencion num_esperas_requerido semilla
\end{verbatim}

Donde:
\begin{itemize}
    \item \textbf{media\_entre\_llegadas}: Tiempo medio entre llegadas (float)
    \item \textbf{media\_atencion}: Tiempo medio de atención (float)
    \item \textbf{num\_esperas\_requerido}: Número de clientes a simular (integer)
    \item \textbf{semilla}: Semilla para el generador aleatorio (integer)
\end{itemize}

\subsubsection{Salidas de la simulación}

El programa genera los siguientes archivos de salida:

\begin{itemize}
    \item \texttt{result.txt}: Reporte detallado de parámetros y métricas principales (tiempos promedio, ocupación, etc.)
    \item \texttt{resultados\_simulacion.csv}: Datos por cliente (opcional, para análisis detallado)
    \item Salida estándar (consola): Línea resumen en formato CSV para integración con scripts externos
\end{itemize}

\subsubsection{Funciones principales}

\paragraph{\texttt{main()}}
\begin{itemize}
    \item Lee parámetros de \texttt{param.txt} o desde la línea de comandos
    \item Inicializa el sistema
    \item Ejecuta el bucle principal de simulación hasta completar el número de clientes requerido
    \item Coordina el cálculo y reporte de resultados
\end{itemize}

\paragraph{\texttt{controltiempo()}}
\begin{itemize}
    \item Determina el siguiente evento (llegada o salida)
    \item Actualiza el reloj de simulación
\end{itemize}

\paragraph{\texttt{llegada()}, \texttt{salida()}}
\begin{itemize}
    \item \texttt{llegada()}: Procesa la llegada de un cliente, actualiza la cola y programa el siguiente evento
    \item \texttt{salida()}: Procesa la salida de un cliente, actualiza el estado del servidor y la cola
\end{itemize}

\paragraph{\texttt{reportes()}}
\begin{itemize}
    \item Calcula métricas agregadas: tiempo promedio en cola, ocupación del servidor, tiempo total de simulación
    \item Exporta los resultados a los archivos de salida
    \item Imprime resumen en consola para integración con scripts
\end{itemize}

\subsubsection{Compilación y ejecución}

Para compilar y ejecutar el simulador:

\begin{verbatim}
g++ SistemadeColas.cpp lcgrand.cpp -o SistemadeColas
./SistemadeColas
\end{verbatim}

También puede ejecutarse con parámetros desde la línea de comandos:

\begin{verbatim}
./SistemadeColas <media_entre_llegadas> <media_atencion> <num_esperas_requerido> <semilla>
\end{verbatim}

\subsubsection{Extensión del código}

Para modificar o extender el código:
\begin{itemize}
    \item Para cambiar el generador de números aleatorios, modificar \texttt{lcgrand.cpp}
    \item Para añadir nuevas métricas, extender \texttt{reportes()}
    \item Para cambiar el modelo de llegadas/servicios, modificar \texttt{expon()} y la lógica de eventos
\end{itemize}

\subsection{Erlang B y C}\label{subsec:erlangbc}

Simulador de sistemas de colas M/M/m implementado en C++ que soporta dos configuraciones:
\begin{itemize}
    \item \textbf{Erlang B}: Sistema sin cola (clientes bloqueados cuando todos los servidores están ocupados)
    \item \textbf{Erlang C}: Sistema con cola infinita (clientes esperan cuando todos los servidores están ocupados)
\end{itemize}

El programa modela un sistema de colas con:
\begin{itemize}
    \item Llegadas y servicios exponenciales
    \item Múltiples servidores ($m$)
    \item Disciplina FIFO
\end{itemize}

\section{Prerequisitos}
\subsection{Software Requerido}
\begin{itemize}
    \item Compilador C++ compatible con C++11 o superior
    \item Bibliotecas estándar: \texttt{stdio.h}, \texttt{stdlib.h}, \texttt{math.h}
    \item Generador de números aleatorios (\texttt{lcgrand.cpp})
    \item Sistema operativo: Windows/Linux/macOS
\end{itemize}

\subsection{Hardware Mínimo}
\begin{itemize}
    \item Procesador: Arquitectura x86/x64
    \item Memoria RAM: 512 MB
    \item Espacio en disco: 10 MB
\end{itemize}

\section{Estructura del Código}
\subsection{Variables Globales Principales}
\subsubsection{Parámetros del Sistema}
\begin{lstlisting}[language=C++]
float media_entre_llegadas;    // Tiempo medio entre llegadas
float media_atencion;          // Tiempo medio de servicio
int num_esperas_requerido;     // Numero de clientes a simular
int num_servidores;           // Numero de servidores (m)
int modo;                     // ERLANG_B (0) o ERLANG_C (1)
\end{lstlisting}

\subsubsection{Estado del Sistema}
\begin{lstlisting}[language=C++]
int servidores_ocupados;      // Numero actual de servidores ocupados
int num_entra_cola;          // Numero de clientes en cola
float tiempo_simulacion;     // Reloj de simulacion
float* tiempo_sig_evento;    // Array de eventos futuros
float tiempo_llegada[LIMITE_COLA + 1]; // Tiempos de llegada en cola
\end{lstlisting}

\subsection{Funciones Principales}
\subsubsection{\texttt{main()}}
\textbf{Propósito}: Función principal que coordina toda la simulación.

\textbf{Funcionalidad}:
\begin{itemize}
    \item Lee parámetros del archivo \texttt{param.txt}
    \item Inicializa el sistema según el modo (Erlang B o C)
    \item Ejecuta el bucle principal de simulación
    \item Genera reportes finales
\end{itemize}

\textbf{Formato del archivo de parámetros}:
\begin{lstlisting}
media_entre_llegadas media_atencion num_esperas_requerido modo num_servidores
\end{lstlisting}

\subsubsection{\texttt{inicializar()}}
\textbf{Propósito}: Prepara el sistema para la simulación.

\textbf{Gestión de memoria}:
\begin{lstlisting}[language=C++]
area_estado_servidores = new float[num_servidores];
tiempo_sig_evento = (float*) malloc((num_eventos + 1) * sizeof(float));
\end{lstlisting}

\section{Parámetros de Configuración}
\subsection{Archivo de Entrada (\texttt{param.txt})}
\begin{lstlisting}
5.0 6.0 1000 1 3
\end{lstlisting}

\textbf{Interpretación}:
\begin{itemize}
    \item 5.0: Media entre llegadas (minutos)
    \item 6.0: Media de atención (minutos)
    \item 1000: Número de clientes a simular
    \item 1: Modo (0=Erlang B, 1=Erlang C)
    \item 3: Número de servidores
\end{itemize}

\section{Validación y Testing}
\subsection{Verificación de Resultados Teóricos}
\textbf{Erlang B - Probabilidad de bloqueo}:
\[ P_b = \frac{\frac{A^m}{m!}}{\sum_{k=0}^{m}\frac{A^k}{k!}} \]
donde $A = \lambda/\mu$ (intensidad de tráfico)

\textbf{Erlang C - Probabilidad de espera}:
\[ P_w = \frac{\frac{A^m}{m!} \cdot \frac{1}{1-\rho}}{\left[\sum_{k=0}^{m-1}\frac{A^k}{k!} + \frac{A^m}{m!} \cdot \frac{1}{1-\rho}\right]} \]
donde $\rho = \lambda/(m \cdot \mu)$ (utilización del sistema)

\section{Compilación y Ejecución}
\subsection{Comando de Compilación}
\begin{lstlisting}[language=bash]
g++ "Sistema de Colas.cpp" -o SistemaDeColas
\end{lstlisting}

\subsection{Ejecución}
\begin{lstlisting}[language=bash]
./SistemaDeColas
\end{lstlisting}

\subsection{Geo/Geo/m}\label{subsec:geogeo_m}

Simulador de un sistema de colas $(Geom/Geom/m):(FIFO/N/+ \infty)$ implementado en C++. El programa modela un sistema de colas con llegadas y servicios geométricos, múltiples servidores (m), capacidad finita (N) y disciplina FIFO.

\subsubsection{Prerequisitos}

\begin{itemize}
    \item Compilador C++ compatible con C++11 o superior
    \item Bibliotecas estándar: \texttt{stdio.h}, \texttt{stdlib.h}, \texttt{math.h}, \texttt{time.h}, \texttt{vector}
    \item Generador de números aleatorios proporcionado en \texttt{lcgrand.cpp}
    \item Sistema operativo: Windows/Linux/macOS
\end{itemize}

\subsubsection{Estructura del código}

El programa sigue una estructura modular con las siguientes componentes principales:

\begin{itemize}
    \item \textbf{Variables globales}:
    \begin{itemize}
        \item Parámetros del sistema (N, m, p, s, num\_slots)
        \item Estado del sistema (estado\_actual, servidores\_ocupados, cola\_length)
        \item Estadísticas (tiempo\_en\_estado[], clientes\_perdidos, clientes\_llegados)
    \end{itemize}
    
    \item \textbf{Funciones principales}:
    \begin{itemize}
        \item \texttt{main()}: Coordina el flujo del programa
        \item \texttt{inicializar()}: Prepara el sistema para la simulación
        \item \texttt{simular\_slot()}: Avanza la simulación un paso de tiempo
        \item \texttt{calcular\_estadisticas()}: Calcula métricas de desempeño
    \end{itemize}
    
    \item \textbf{Funciones auxiliares}:
    \begin{itemize}
        \item Generación aleatoria: \texttt{generar\_bernoulli()}, \texttt{generar\_binomial()}
        \item Cálculos matemáticos: \texttt{factorial()}, \texttt{potencia()}, \texttt{comb()}
        \item Modelo teórico: \texttt{geom\_geom\_m\_N\_p\_calc()}, \texttt{a\_func()}
    \end{itemize}
\end{itemize}

\subsubsection{Parámetros de la simulación}

Los parámetros se leen del archivo \texttt{paramGeo.txt} con el formato:

\begin{verbatim}
N m p s num_slots
\end{verbatim}

Donde:
\begin{itemize}
    \item \textbf{N}: Capacidad máxima del sistema (clientes)
    \item \textbf{m}: Número de servidores
    \item \textbf{p}: Probabilidad de llegada en un slot
    \item \textbf{s}: Probabilidad de finalización de servicio en un slot
    \item \textbf{num\_slots}: Duración de la simulación (slots)
\end{itemize}

\subsubsection{Salidas de la simulación}

El programa genera tres archivos de salida:

\begin{itemize}
    \item \texttt{estadisticas.txt}: Distribución de probabilidad del número de clientes en el sistema y probabilidad de bloqueo
    \item \texttt{comparacion\_teorica.txt}: Comparación entre resultados simulados y teóricos
    \item \texttt{resumen\_resultados.txt}: Métricas agregadas (utilización, promedio de clientes, throughput)
\end{itemize}

\subsubsection{Funciones principales}

\paragraph{\texttt{main()}}
\begin{itemize}
    \item Lee parámetros de \texttt{paramGeo.txt}
    \item Inicializa el sistema
    \item Ejecuta el bucle principal de simulación
    \item Coordina el cálculo y reporte de resultados
\end{itemize}

\paragraph{\texttt{simular\_slot()}}
\begin{itemize}
    \item Genera llegadas usando distribución Bernoulli(p)
    \item Genera salidas usando distribución Binomial(servidores\_ocupados, s)
    \item Actualiza el estado del sistema
    \item Registra estadísticas
\end{itemize}

\paragraph{\texttt{geom\_geom\_m\_N\_p\_calc()}}
Implementa el algoritmo para calcular las probabilidades de estado estacionario teóricas según el modelo Geom/Geom/m/N, basado en:
\begin{itemize}
    \item Thomas G. Robertazzi \textit{Computer Networks and Systems: Queueing Theory and Performance Evaluation Third Edition}
    \item 6.4 The Geom/Geom/m/N Queing system
\end{itemize}

\paragraph{\texttt{a\_func()}}
Función auxiliar que calcula $a_{i,j} \ 's$

\subsubsection{Compilación y ejecución}

Para compilar y ejecutar el simulador:

\begin{verbatim}
g++ sistemaGeoGeo.cpp -o sistemaGeoGeo 
./sistemaGeoGeo
\end{verbatim}

\subsubsection{Extensión del código}

Para modificar o extender el código:
\begin{itemize}
    \item Para cambiar el generador de números aleatorios, modificar \texttt{lcgrand.cpp}
    \item Para añadir nuevas métricas, extender \texttt{calcular\_estadisticas()}
    \item Para cambiar el modelo de llegadas/servicios, modificar \texttt{simular\_slot()}
\end{itemize}




%---------------------------------------------------------------------------------
% Exprimentación ------------------------------------------------------------------
%---------------------------------------------------------------------------------


\section{Experimentación y Resultados}\label{sec:exp}

\subsection{Modelo M/M/1}

Para probar la hipótesis, se introduce una \textbf{variación sistemática} de los parámetros clave del sistema M/M/1, con el objetivo de evaluar su impacto sobre el rendimiento del sistema. Específicamente, se examinan tres factores:

\begin{enumerate}
  \item \textbf{Tasa de llegada} de clientes al sistema (\texttt{lambda}), que determina el intervalo promedio entre arribos.
  \item \textbf{Tasa de atención} del servidor (\texttt{mu}), que define la rapidez con la que los clientes son atendidos.
  \item \textbf{Número total de clientes} a procesar en cada simulación.
\end{enumerate}

Además, se incluye la \textbf{semilla del generador de números aleatorios} para garantizar la replicabilidad de cada experimento.

Cada simulación sigue la lógica básica del modelo M/M/1: llegadas y tiempos de servicio generados a partir de distribuciones exponenciales, y una única cola con un solo servidor. Se registran métricas como:

\begin{itemize}
  \item \textbf{Tiempo promedio en cola},
  \item \textbf{Tiempo promedio en el sistema},
  \item \textbf{Longitud promedio de la cola},
  \item \textbf{Utilización del servidor}.
\end{itemize}

\subsubsection*{Escenarios de Experimentación}

Con el fin de evaluar de manera robusta el comportamiento del sistema M/M/1 bajo distintas condiciones de carga, se definieron múltiples configuraciones experimentales variando los siguientes parámetros clave:

\begin{itemize}
  \item \textbf{Tiempo promedio entre llegadas (\(\lambda^{-1}\))}: 8 s, 5 s, 2 s
  \item \textbf{Tiempo promedio de atención (\(\mu^{-1}\))}: 6 s, 5 s
  \item \textbf{Número de clientes por simulación}: 500, 1000
  \item \textbf{Semilla del generador aleatorio}: 1, 2
  \item \textbf{Número de repeticiones por configuración}: 5
\end{itemize}

\textbf{Parámetros Comunes para Todos los Escenarios}:

\begin{itemize}
  \item \textbf{Modelo de Cola}: M/M/1
  \item \textbf{Distribución de Llegadas}: Exponencial con tasa \(\lambda\)
  \item \textbf{Distribución de Atención}: Exponencial con tasa \(\mu\)
  \item \textbf{Unidad de tiempo}: segundos
  \item \textbf{Servidor}: único, sin interrupciones
  \item \textbf{Disciplina de atención}: FIFO (primero en llegar, primero en ser atendido)
\end{itemize}

En la siguiente sección se describen detalladamente los tres escenarios simulados y se analizan sus resultados.

\subsubsection{Escenario 0: Condición Estable}

\begin{itemize}
    \item \textbf{Objetivo:} Evaluar el desempeño del sistema M/M/1 bajo una condición estable, en la que la tasa de atención supera a la de llegada, garantizando un flujo eficiente de clientes y mínima congestión.

    \item \textbf{Parámetros de simulación:}
    \begin{itemize}
        \item \textbf{Tiempo promedio de llegada ($\lambda$):} 0.125 clientes/seg (media = 8 s)
        \item \textbf{Tiempo promedio de atención ($\mu$):} 0.166 clientes/seg (media = 6 s)
        \item \textbf{Número total de clientes:} 1000
        \item \textbf{Semillas:} 1 y 2 (con 5 repeticiones por semilla)
    \end{itemize}

    \item \textbf{Resultados esperados:} 
    El sistema debería permanecer estable durante toda la simulación. Se espera un tiempo promedio en cola bajo, una utilización del servidor menor al 100\%, y una cola que no crece de manera indefinida.


\end{itemize}
\begin{table}[H]
\centering
\caption{Resumen de métricas clave para el Escenario 0 (M/M/1, media llegada = 8s, media atención = 6s)}
\label{tab:escenario0}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
\textbf{Semilla} & \textbf{Llegada Prom.} & \textbf{Atención Prom.} & \textbf{Espera Prom.} & \textbf{Long. Cola Prom.} & \textbf{Uso del Servidor} \\
\hline
1  & 8.423 & 5.552 & 11.566 & 1.373 & 0.655 \\
2  & 7.621 & 6.042 & 22.119 & 2.901 & 0.792 \\
4  & 7.983 & 5.810 & 16.191 & 2.027 & 0.726 \\
6  & 7.998 & 5.767 & 14.007 & 1.749 & 0.720 \\
7  & 7.767 & 5.878 & 17.531 & 2.255 & 0.754 \\
9  & 8.132 & 5.691 & 11.946 & 1.469 & 0.699 \\
11 & 7.756 & 5.919 & 24.057 & 3.102 & 0.762 \\
12 & 8.152 & 6.089 & 15.356 & 1.889 & 0.749 \\
\hline
\end{tabular}
\end{table}

\textbf{Análisis de los resultados:}  
Se observa que, aunque la tasa promedio de llegada (alrededor de 8 segundos por cliente) es ligeramente más lenta que la de atención (alrededor de 6 segundos por cliente), el sistema presenta acumulación en la cola. Esto es evidente en el tiempo promedio de espera, que varía entre 11 y 24 segundos, y en la longitud promedio de la cola (entre 1.3 y 3.1 clientes).  

El uso del servidor oscila entre 65.5\% y 79.2\%, lo que indica que el sistema se mantiene ocupado la mayor parte del tiempo, pero sin llegar a saturarse completamente. Estos resultados confirman que, incluso con una tasa de llegada ligeramente inferior a la de atención, pueden generarse colas significativas debido a la variabilidad estocástica inherente al modelo M/M/1.  

Esto valida la hipótesis del escenario: se genera una cola moderada, con un aumento considerable en el tiempo total en el sistema, especialmente bajo ciertas condiciones de aleatoriedad (por ejemplo, semillas con tiempos de atención más largos o llegadas más frecuentes).

\subsubsection{Escenario 1: Condición Crítica}

\begin{itemize}
    \item \textbf{Objetivo:} Analizar el comportamiento del sistema M/M/1 en condiciones críticas, donde la tasa de llegada es prácticamente igual a la de atención, evaluando el riesgo de congestión sostenida.

    \item \textbf{Parámetros de simulación:}
    \begin{itemize}
        \item \textbf{Tiempo promedio de llegada ($\lambda$):} 0.2 clientes/seg (media = 5 s)
        \item \textbf{Tiempo promedio de atención ($\mu$):} 0.2 clientes/seg (media = 5 s)
        \item \textbf{Número total de clientes:} 500
        \item \textbf{Semillas:} 1 y 2 (con 5 repeticiones por semilla)
    \end{itemize}

    \item \textbf{Resultados esperados:} 
    Debido al equilibrio entre llegadas y atención, pequeñas variaciones aleatorias pueden generar acumulación de clientes. Se espera observar picos en la longitud de la cola y un tiempo promedio en el sistema más elevado que en el escenario estable.

    \item \textbf{Visualización:} 
    Se grafican la evolución de la cola en el tiempo, la utilización del servidor, y la distribución de tiempos en cola por cliente. También puede presentarse la desviación estándar de los tiempos como indicador de inestabilidad.

\end{itemize}

\subsubsection{Escenario 2: Condición Sobrecargada}

\begin{itemize}
    \item \textbf{Objetivo:} Evaluar el comportamiento del sistema M/M/1 bajo una alta carga, donde la tasa de llegada de clientes es mayor que la capacidad de atención, simulando una situación de saturación del sistema.

    \item \textbf{Parámetros de simulación:}
    \begin{itemize}
        \item \textbf{Tiempo promedio de llegada ($\lambda$):} 0.5 clientes/seg (media = 2 s)
        \item \textbf{Tiempo promedio de atención ($\mu$):} 0.2 clientes/seg (media = 5 s)
        \item \textbf{Número total de clientes:} 1000
        \item \textbf{Semillas:} 1 y 2 (con 5 repeticiones por semilla)
    \end{itemize}

    \item \textbf{Resultados esperados:} 
    Se anticipa un crecimiento continuo de la cola durante la simulación. El tiempo promedio en el sistema aumentará significativamente y la utilización del servidor será cercana o igual al 100\%, reflejando un sistema incapaz de responder a la demanda.

    \item \textbf{Visualización:} 
    Se presentan gráficas del tamaño de la cola en función del tiempo, histogramas de los tiempos de espera por cliente y análisis de la acumulación progresiva de clientes no atendidos.

\end{itemize}

El objetivo principal de esta experimentación es validar la implementación del simulador Geo/Geo/m/N mediante el análisis de convergencia hacia los valores teóricos del modelo, variando sistemáticamente el número de slots de tiempo para evaluar cómo afecta la precisión de las estimaciones.

\subsection{Pruebas Erlang}\label{subsec:pruebas_erlang}

\subsubsection{Erlang B, probabilidad de bloqueo}\label{subsec:erlang_b_prob_bloq}

Para validar el simulador, se realizó un experimento con los siguientes parámetros:

\begin{itemize}
    \item Media entre llegadas ($\lambda$): 5 minutos
    \item Media de atención ($\mu$): 6 minutos
    \item Número de clientes a simular: 100
    \item Modo: 0 (Erlang B, sin cola)
    \item Número de servidores ($m$): 2
\end{itemize}

\textbf{Cálculo teórico:}

La fórmula de Erlang B para la probabilidad de bloqueo $p_m$ es:
\begin{equation*}
p_m = \frac{\frac{1}{m!}\left(\frac{\lambda}{\mu}\right)^m}{1 + \sum_{n=1}^{m} \frac{1}{n!}\left(\frac{\lambda}{\mu}\right)^n}
\end{equation*}
donde:
\begin{itemize}
    \item $\lambda$ es la tasa de llegadas
    \item $\mu$ es la tasa de servicio
    \item $m$ es el número de servidores
\end{itemize}

Para este caso:
\begin{align*}
    \lambda &= 1/5 \text{ clientes/minuto} \\
    \mu &= 1/6 \text{ clientes/minuto} \\
    A &= \frac{1/5}{1/6} = 1.2 \\
    m &= 2
\end{align*}

\begin{align*}
p_m &= \frac{\frac{1}{2!}\left(\frac{1/5}{1/6}\right)^2}{1 + \frac{1}{1!}\left(\frac{1/5}{1/6}\right)^1 + \frac{1}{2!}\left(\frac{1/5}{1/6}\right)^2} \\
    &= \frac{\frac{1}{2}\cdot(1.2)^2}{1 + 1.2 + \frac{1}{2}\cdot(1.2)^2} \\
    &= \frac{0.72}{2.92} \approx 0.2466
\end{align*}

\textbf{Resultados simulados:}

\begin{verbatim}
Sistema de Colas Simple

Tiempo promedio de llegada      5.000 minutos
Tiempo promedio de atencion           6.000 minutos
Numero de clientes           100
Modo de simulación:              Erlang B (sin cola)
Número de servidores (m):        2
Espera promedio en la cola      0.000 minutos
Numero promedio en cola     0.000
Uso de Servidores
Uso del servidor 1 :           0.021
Uso del servidor 2 :           0.544
Tiempo de terminacion de la simulacion     982.220 minutos>>> Modo Erlang B (sin cola)
Clientes bloqueados (rechazados):           105
Probabilidad de bloqueo estimada (P_b):          0.5426
\end{verbatim}

\textbf{Análisis:}

El valor simulado de la probabilidad de bloqueo ($P_b = 0.5426$) es considerablemente mayor que el valor teórico ($\approx 0.2466$). Esto es esperable cuando el número de clientes simulados es bajo (100), ya que la variabilidad estadística es mucho mayor y los resultados pueden alejarse del valor teórico. Para obtener una mejor aproximación al valor teórico, se recomienda aumentar el número de clientes simulados (por ejemplo, a 10,000 o más).

\subsubsection{Erlang C, probabilidad de espera}\label{subsec:erlang_c_prob_espe}

Para validar el simulador bajo el modelo Erlang C (con cola), se realizó un experimento con los siguientes parámetros:

\begin{itemize}
    \item Media entre llegadas ($\lambda$): 5 minutos
    \item Media de atención ($\mu$): 6 minutos
    \item Número de clientes a simular: 100
    \item Modo: 1 (Erlang C, con cola)
    \item Número de servidores ($m$): 2
\end{itemize}

\textbf{Cálculo teórico:}

La fórmula de Erlang C para la probabilidad de que un cliente tenga que esperar (haya cola) es:
\begin{equation*}
p(\text{cola}) = \frac{\frac{1}{m!}\left(\frac{\lambda}{\mu}\right)^m \left( \frac{1}{1-\rho} \right)}{1 + \sum_{n=1}^{m-1} \frac{1}{n!}\left(\frac{\lambda}{\mu}\right)^n + \frac{1}{m!}\left(\frac{\lambda}{\mu}\right)^m \left( \frac{1}{1-\rho} \right)}
\end{equation*}
donde:
\begin{itemize}
    \item $\lambda$ es la tasa de llegadas
    \item $\mu$ es la tasa de servicio
    \item $m$ es el número de servidores
    \item $\rho = \frac{\lambda}{m\mu}$ es la utilización del sistema
\end{itemize}

Para este caso:
\begin{align*}
    \lambda &= 1/5 \text{ clientes/minuto} \\
    \mu &= 1/6 \text{ clientes/minuto} \\
    m &= 2 \\
    \rho &= \frac{1/5}{2 \times 1/6} = \frac{1/5}{1/3} = 0.6
\end{align*}

\begin{align*}
p(\text{cola}) &= \frac{\frac{1}{2!}\left(1.2\right)^2 \left( \frac{1}{1-0.6} \right)}{1 + \frac{1}{1!}(1.2)^1 + \frac{1}{2!}(1.2)^2 \left( \frac{1}{1-0.6} \right)} \\
    &= \frac{0.72 \times 2.5}{1 + 1.2 + 0.72 \times 2.5} \\
    &= \frac{1.8}{4.0} = 0.45
\end{align*}

\textbf{Resultados simulados:}

\begin{verbatim}
Sistema de Colas Simple

Tiempo promedio de llegada      5.000 minutos
Tiempo promedio de atencion           6.000 minutos
Numero de clientes           100
Modo de simulación:              Erlang C (con cola)
Número de servidores (m):        2

Espera promedio en la cola      7.972 minutos
Numero promedio en cola     1.330
Uso de Servidores
Uso del servidor 1 :           0.026
Uso del servidor 2 :           0.782
Tiempo de terminacion de la simulacion     599.268 minutos>>> Modo Erlang C (con cola)
Clientes que debieron esperar:              70
Probabilidad de espera estimada (P_w):           0.7761
\end{verbatim}

\textbf{Análisis:}

Dado que el número de clientes simulados es bajo (100), es esperable que la probabilidad de espera simulada difiera del valor teórico ($0.45$) debido a la alta variabilidad estadística inherente a muestras pequeñas. Esto puede provocar que el valor simulado sea mayor o menor que el teórico, y que la dispersión entre ejecuciones sea significativa. Para obtener una mejor aproximación al valor teórico, se recomienda aumentar el número de clientes simulados (por ejemplo, a 10,000 o más), lo que reduce la variabilidad y permite que la simulación converja hacia el valor esperado por la teoría de colas. Si la diferencia entre el valor simulado y el teórico persiste incluso con muestras grandes, se recomienda revisar la correcta interpretación de los parámetros y la implementación del simulador.

\subsubsection{Erlang C, probabilidad de espera con más servidores}

Para analizar el efecto de aumentar el número de servidores en la probabilidad de espera, se realizó un experimento bajo el modelo Erlang C (con cola) con los siguientes parámetros:

\begin{itemize}
    \item Media entre llegadas ($\lambda$): 5 minutos
    \item Media de atención ($\mu$): 6 minutos
    \item Número de clientes a simular: 100
    \item Modo: 1 (Erlang C, con cola)
    \item Número de servidores ($m$): 5
\end{itemize}

\textbf{Cálculo teórico:}

La fórmula de Erlang C para la probabilidad de que un cliente tenga que esperar (haya cola) es:
\begin{equation*}
p(\text{cola}) = \frac{\frac{1}{m!}\left(\frac{\lambda}{\mu}\right)^m \left( \frac{1}{1-\rho} \right)}{1 + \sum_{n=1}^{m-1} \frac{1}{n!}\left(\frac{\lambda}{\mu}\right)^n + \frac{1}{m!}\left(\frac{\lambda}{\mu}\right)^m \left( \frac{1}{1-\rho} \right)}
\end{equation*}
donde:
\begin{itemize}
    \item $\lambda$ es la tasa de llegadas
    \item $\mu$ es la tasa de servicio
    \item $m$ es el número de servidores
    \item $\rho = \frac{\lambda}{m\mu}$ es la utilización del sistema
\end{itemize}

Para este caso:
\begin{align*}
    \lambda &= 1/5 \text{ clientes/minuto} \\
    \mu &= 1/6 \text{ clientes/minuto} \\
    m &= 5 \\
    \rho &= \frac{1/5}{5 \times 1/6} = \frac{1/5}{5/6} = 0.24 \\
    \frac{\lambda}{\mu} &= 1.2
\end{align*}

\begin{align*}
p(\text{cola}) &= \frac{\frac{1}{5!}(1.2)^5 \left( \frac{1}{1-0.24} \right)}{1 + \sum_{n=1}^{4} \frac{1}{n!}(1.2)^n + \frac{1}{5!}(1.2)^5 \left( \frac{1}{1-0.24} \right)} = 0.0082
\end{align*}

\textbf{Resultados simulados:}

\begin{verbatim}
Sistema de Colas Simple

Tiempo promedio de llegada      5.000 minutos

Tiempo promedio de atencion           6.000 minutos

Numero de clientes           100

Modo de simulación:              Erlang C (con cola)
Número de servidores (m):        5

Espera promedio en la cola      7.158 minutos

Numero promedio en cola     1.249

Uso de Servidores

Uso del servidor 1 :           0.026
Uso del servidor 2 :           0.012
Uso del servidor 3 :           0.091
Uso del servidor 4 :           0.032
Uso del servidor 5 :           0.704
Tiempo de terminacion de la simulacion     573.145 minutos>>> Modo Erlang C (con cola)
Clientes que debieron esperar:              60
Probabilidad de espera estimada (P_w):           0.6944
\end{verbatim}

\textbf{Análisis comparativo:}

Al comparar este resultado con el experimento anterior con 2 servidores (donde la probabilidad de espera simulada fue $P_w = 0.7761$), se observa que, aunque la probabilidad de espera disminuye al aumentar el número de servidores, en este caso sigue siendo relativamente alta ($P_w = 0.6944$). Esto puede deberse a la alta variabilidad estadística por el bajo número de clientes simulados (100) o a la configuración de los parámetros de llegada y servicio. 

Teóricamente, al aumentar los servidores, el sistema debería ser capaz de atender a más clientes sin que tengan que esperar, y la probabilidad de espera debería disminuir considerablemente. Para observar esta reducción de manera más clara y obtener una mejor aproximación al valor teórico, se recomienda aumentar el número de clientes simulados (por ejemplo, a 10,000 o más). Si la probabilidad de espera sigue siendo alta incluso con muestras grandes, es importante revisar la correcta interpretación de los parámetros y la implementación del simulador para descartar errores o malentendidos en la lógica del modelo.


\subsection{Modelo Geo/Geo/m/N}

La función de densidad teórica presentada en la seccion 6.4 The Geom/Geom/m/N Queing system del libro Computer Networks and Systems: Queueing Theory and Performance Evaluation Third Edition escrito por Thomas G. Robertazzi se define con el procedimiento:

\begin{enumerate}
    \item Defina $P_N = 1.0$
    \item Inicialice $a_{i,j}\ 's$
    \item $i = N-1$
    \item $	P_i=\frac{1}{a_{i,i+1}}\sum_{n=i+1}^{i+m}\sum_{j=n-m}^{i}{a_{n,j}P_n}$
    \item $i=i-1$
    \item Repetir pasos 4 y 5 hasta que $i<0$
    \item Encontrar $\sum {P_i}$
    \item Dividir todos los $P_i\ 's$ resultantes de los pasos 1 y 4 sobre la suma del paso 7
\end{enumerate}

Tambien para el algoritmo anterior se define $a_{n,n-l}$:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{images/imageGeoGeoMCalc1.png}
    \caption{$a_{n,n-l}$ caso en que un cliente no puede llegar y ser atendido en el mismo slot de tiempo}
    \label{fig:enter-label}
\end{figure}

\begin{figure} [H]
    \centering
    \includegraphics[width=0.5\linewidth]{images/imageGeoGeoMCalc2.png}
    \caption{$a_{N,N}$ caso en que un cliente no puede llegar y ser atendido en el mismo slot de tiempo}
    \label{fig:enter-label}
\end{figure}

Para el caso en que un cliente puede llegar y ser atendido en el mismo slot de tiempo, para el caso contrario se tienen algunas variaciones de $a_{n,n-l}$

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{images/imageGeoGeoMCalc3.png}
    \caption{$a_{n,n-l}$ caso en que un cliente puede llegar y ser atendido en el mismo slot de tiempo}
    \label{fig:enter-label}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{images/imageGeoGeoMCalc4.png}
    \caption{$a_{N,N}$ caso en que un cliente puede llegar y ser atendido en el mismo slot de tiempo}
    \label{fig:enter-label}
\end{figure}

Teniendo esto en cuenta se programa en Py cada paso de la siguiente forma:

Paso 1: Se define $P_N$ y el arreglo P:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{images/imageGeoGeoMCalc5.png}
    \caption{Paso 1}
    \label{fig:enter-label}
\end{figure}

Paso 2: No se inicializan las $a_{i,j}\ ´s$ si no las funciones que permiten obtenerlas, acá se llama la función de combinación combEq0() que devuelve 0 para combinaciones invalidas.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{images/imageGeoGeoMCalc6.png}
    \caption{Paso 2}
    \label{fig:enter-label}
\end{figure}

Paso 3,4,5,6: Se inicializa $i$, i se itera decreciendo i para obetener los $P_i \ 's$ hasta que $i<0$

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{images/imageGeoGeoMCalc7.png}
    \caption{Pasos 3, 4, 5 y 6}
    \label{fig:enter-label}
\end{figure}

Paso 7: Se calcula la sumatoria de los $P_i$
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{images/imageGeoGeoMCalc8.png}
    \caption{Paso 7}
    \label{fig:enter-label}
\end{figure}

Paso 8: Se normalizan los $P_i$
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{images/imageGeoGeoMCalc9.png}
    \caption{Paso 8}
    \label{fig:enter-label}
\end{figure}

\subsubsection{Diseño Experimental}

\paragraph{Parámetros del Sistema:}

Para esta experimentación se utilizaron parámetros específicos que representan un sistema moderadamente cargado:
\begin{itemize}
    \item $N=5$: Capacidad máxima del sistema
    \item $m=5$: Número de servidores
    \item $p=0.30$: Probabilidad de llegada por slot
    \item $s=0.40$: Probabilidad de completar servicio por slot
\end{itemize}

\paragraph{Escenarios Experimentales}
Se diseñaron tres escenarios para analizar el efecto del tamaño muestral en la convergencia:
\begin{enumerate}
    \item \textbf{Escenario 1}: Simulación Corta - 100,000 slots
    \item \textbf{Escenario 2}: Simulación Media - 500,000 slots
    \item \textbf{Escenario 3}: Simulación Larga - 2,000,000 slots
\end{enumerate}

\paragraph{Metodología Estadística}
Cada escenario se ejecutó con 30 réplicas independientes para:
\begin{itemize}
    \item Obtener intervalos de confianza del 95\%
    \item Calcular medias y desviaciones estándar robustas
    \item Evaluar la variabilidad entre ejecuciones
    \item Aplicar el teorema del límite central
\end{itemize}

\paragraph{Métricas de Evaluación}
Se evaluaron las siguientes métricas de desempeño:
\begin{itemize}
    \item \textbf{Función de densidad}: $\hat{P}_n$ para $n = 0, 1, 2, 3, 4, 5$
    \item \textbf{Probabilidad de bloqueo}: $\hat{p}_b$
    \item \textbf{Métricas operacionales}: Utilización, número promedio de clientes, throughput
    \item \textbf{Métricas de convergencia}: Error relativo, coeficiente de variación, error estándar
\end{itemize}

\subsubsection{Resultados Experimentales}

\paragraph{Escenario 1: Simulación Corta (100,000 slots)}

\textbf{Función de Densidad de Estados:}
\begin{table}[H]
    \centering
    \caption{Resultados Escenario 1 - Función de densidad de estados}
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        \textbf{Estado} & \textbf{P\_simulada} & \textbf{Desv\_Std} & \textbf{P\_teórica} & \textbf{Error\_Abs} & \textbf{Error\_Rel(\%)} \\
        \hline
        0 & 0.433036 & 0.002572 & 0.433954 & 0.000919 & 0.21 \\
        1 & 0.407581 & 0.001741 & 0.407088 & 0.000493 & 0.12 \\
        2 & 0.135981 & 0.001744 & 0.135865 & 0.000116 & 0.09 \\
        3 & 0.021515 & 0.000598 & 0.021273 & 0.000242 & 1.14 \\
        4 & 0.001791 & 0.000148 & 0.001739 & 0.000051 & 2.94 \\
        5 & 0.000096 & 0.000029 & 0.000080 & 0.000016 & 19.87 \\
        \hline
    \end{tabular}
\end{table}

\textbf{Análisis del Escenario 1:}
Los estados más probables (0, 1, 2) muestran una excelente aproximación con errores relativos inferiores al 0.25\%. Sin embargo, el estado menos probable (estado 5) presenta un error relativo del 19.87\% , evidenciando las limitaciones del tamaño muestral para eventos raros.

\textbf{Probabilidad de Bloqueo:}
\begin{align}
    \hat{p}_b &= 0.00001112 \pm 0.00002026 \\
    p_b &= 0.00000623 \\
    \text{Error relativo} &= 78.57\%
\end{align}
El intervalo de confianza del 95\% es [0.00000355, 0.00001869], el cual contiene el valor teórico. El alto coeficiente de variación (1.8223) indica una variabilidad considerable entre réplicas.

\paragraph{Escenario 2: Simulación Media (500,000 slots)}

\textbf{Función de Densidad de Estados:}
\begin{table}[H]
    \centering
    \caption{Resultados Escenario 2 - Función de densidad de estados}
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        \textbf{Estado} & \textbf{P\_simulada} & \textbf{Desv\_Std} & \textbf{P\_teórica} & \textbf{Error\_Abs} & \textbf{Error\_Rel(\%)} \\
        \hline
        0 & 0.433181 & 0.000723 & 0.433954 & 0.000773 & 0.18 \\
        1 & 0.407519 & 0.000594 & 0.407088 & 0.000431 & 0.11 \\
        2 & 0.135997 & 0.000612 & 0.135865 & 0.000131 & 0.10 \\
        3 & 0.021425 & 0.000199 & 0.021273 & 0.000152 & 0.71 \\
        4 & 0.001781 & 0.000032 & 0.001739 & 0.000042 & 2.39 \\
        5 & 0.000097 & 0.000006 & 0.000080 & 0.000017 & 21.37 \\
        \hline
    \end{tabular}
\end{table}

\textbf{Análisis del Escenario 2:}
Se observa una reducción significativa en las desviaciones estándar (factor de 3-4) para todos los estados, confirmando el efecto estabilizador del aumento del tamaño muestral. Los errores relativos se mantienen consistentemente bajos para los estados principales.

\textbf{Probabilidad de Bloqueo:}
\begin{align}
    \hat{p}_b &= 0.00000998 \pm 0.00000969 \\
    \text{Error relativo} &= 60.25\%
\end{align}
El coeficiente de variación se reduce a 0.9706, representando una mejora del 47\% respecto al escenario anterior. Sin embargo, el valor teórico queda fuera del intervalo de confianza [0.00000636, 0.00001360].

\paragraph{Escenario 3: Simulación Larga (2,000,000 slots)}

\textbf{Función de Densidad de Estados:}
\begin{table}[H]
    \centering
    \caption{Resultados Escenario 3 - Función de densidad de estados}
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        \textbf{Estado} & \textbf{P\_simulada} & \textbf{Desv\_Std} & \textbf{P\_teórica} & \textbf{Error\_Abs} & \textbf{Error\_Rel(\%)} \\
        \hline
        0 & 0.433100 & 0.000239 & 0.433954 & 0.000854 & 0.20 \\
        1 & 0.406955 & 0.000252 & 0.407088 & 0.000133 & 0.03 \\
        2 & 0.136554 & 0.000127 & 0.135865 & 0.000689 & 0.51 \\
        3 & 0.021528 & 0.000075 & 0.021273 & 0.000255 & 1.20 \\
        4 & 0.001778 & 0.000010 & 0.001739 & 0.000039 & 2.24 \\
        5 & 0.000085 & 0.000006 & 0.000080 & 0.000005 & 6.49 \\
        \hline
    \end{tabular}
\end{table}

\textbf{Análisis del Escenario 3:}
Este escenario produce los resultados más precisos, con una mejora dramática en la estimación del estado 5 (error relativo reducido de 21.37\% a 6.49\%). Todas las desviaciones estándar alcanzan sus valores mínimos.

\textbf{Probabilidad de Bloqueo:}
\begin{align}
    \hat{p}_b &= 0.00000627 \pm 0.00000320 \\
    p_b &= 0.00000623 \\
    \text{Error relativo} &= 0.64\%
\end{align}
Se logra una convergencia prácticamente perfecta, con el valor teórico dentro del intervalo de confianza [0.00000507, 0.00000746] y un error relativo inferior al 1\%.

\subsubsection{Análisis de Convergencia}
La progresión de las métricas de convergencia demuestra el comportamiento esperado según la Ley de los Grandes Números:
\begin{table}[H]
    \centering
    \caption{Evolución de métricas de convergencia para la probabilidad de bloqueo}
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Métrica} & \textbf{100K slots} & \textbf{500K slots} & \textbf{2M slots} \\
        \hline
        Error relativo (\%) & 78.57 & 60.25 & 0.64 \\
        Coeficiente de variación & 1.8223 & 0.9706 & 0.5105 \\
        Error estándar & $3.70 \times 10^{-6}$ & $1.77 \times 10^{-6}$ & $5.8 \times 10^{-7}$ \\
        \hline
    \end{tabular}
\end{table}

\subsubsection{Métricas Operacionales del Sistema}
Las métricas operacionales se mantuvieron notablemente estables a través de todos los escenarios:
\begin{table}[H]
    \centering
    \caption{Métricas operacionales del sistema por escenario}
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Métrica} & \textbf{100K slots} & \textbf{500K slots} & \textbf{2M slots} \\
        \hline
        Utilización (\%) & 56.70 & 56.68 & 56.69 \\
        Número promedio de clientes & 0.7517 & 0.7514 & 0.7522 \\
        Throughput (clientes/slot) & 0.300352 & 0.300452 & 0.300449 \\
        \hline
    \end{tabular}
\end{table}
Esta consistencia valida la correcta implementación del simulador y confirma que las variaciones observadas en las probabilidades de estado se deben únicamente a la variabilidad estadística.

\subsubsection{Discusión de Resultados}

\paragraph{Validación del Modelo Teórico}
La convergencia sistemática hacia los valores teóricos del algoritmo de Robertazzi confirma:
\begin{itemize}
    \item La correcta implementación del simulador Geo/Geo/m/N
    \item La validez del modelo teórico para estos parámetros
    \item La aplicabilidad práctica del método para sistemas discretos
\end{itemize}

\paragraph{Implicaciones para Eventos Raros}
La probabilidad de bloqueo ($p_b \approx 6.23 \times 10^{-6}$) representa un desafío típico en simulación de eventos raros:
\begin{itemize}
    \item Requiere simulaciones extensas para obtener estimaciones precisas
    \item La variabilidad decrece proporcionalmente a $\sqrt{n}$ donde $n$ es el número de slots
    \item Para errores relativos < 5\%, se necesitan al menos 2 millones de slots
\end{itemize}

\paragraph{Eficiencia Computacional vs. Precisión}
Los resultados sugieren un trade-off óptimo:
\begin{itemize}
    \item \textbf{100K slots}: Adecuado para análisis preliminares (tiempo: segundos)
    \item \textbf{500K slots}: Equilibrio entre precisión y tiempo computacional (tiempo: minutos)
    \item \textbf{2M slots}: Máxima precisión para análisis definitivos (tiempo: decenas de minutos)
\end{itemize}

\subsubsection{Conclusiones de la Experimentación}
\begin{enumerate}
    \item \textbf{Convergencia verificada}: El simulador converge consistentemente hacia los valores teóricos, validando tanto la implementación como el modelo de Robertazzi.
    \item \textbf{Escalabilidad del error}: Los eventos raros requieren tamaños muestrales significativamente mayores, siguiendo el comportamiento teórico esperado.
    \item \textbf{Robustez estadística}: Las 30 réplicas independientes proporcionan intervalos de confianza confiables y permiten evaluar la variabilidad entre ejecuciones.
    \item \textbf{Aplicabilidad práctica}: Los resultados demuestran que el modelo Geo/Geo/m/N es una herramienta válida para el análisis de sistemas de colas discretos en aplicaciones reales.
    \item \textbf{Recomendación metodológica}: Para sistemas con probabilidades de bloqueo del orden de $10^{-6}$, se recomienda un mínimo de 2 millones de slots para obtener estimaciones con error relativo inferior al 1\%.
\end{enumerate}

Esta experimentación establece una base sólida para la aplicación del simulador en estudios más complejos y valida la metodología propuesta para el análisis de sistemas de colas discretos.

\section{Referencias}
\renewcommand{\refname}{}
\begin{thebibliography}{9}

\bibitem{ref} \label{ref:modSim} A. M. Law, *Simulation Modeling and Analysis*, 5th ed. 
New York, NY, USA: McGraw-Hill Education, Jan. 2014, ISBN 978-0-07-340132-4. 

\bibitem{ref} \label{ref:matSim} J. E. Ortiz T., "Modelos Matemáticos \& Simulación,"
 en *Apuntes de clase de la asignatura Modelos Estocásticos y Simulación en 
 Computación y Comunicaciones*, Departamento de Ingeniería de Sistemas e Industrial, 
 Universidad Nacional de Colombia, 2025. [En línea]. Disponible en: 
 \url{https://drive.google.com/file/d/1c886yU4SFk9A97DGWr8JHiF3nd2au1Ns/view?usp=sharing}

 \bibitem{ref} \label{ref:cimColas} J. E. UOrtiz, "Simulador del modelo de colas M/M/1," 
 código fuente en C++ (archivo .rar), basado en la sección 
 1.4.4 de Averill M. Law, *Simulation Modeling and Analysis*, 
 th ed., McGraw-Hill, 2014. [En línea]. Disponible en: 
 \url{https://drive.google.com/file/d/1-Mo9hqPwOegwTpx0KP2tbD9sLTNSXefd/view?usp=sharing}



\end{thebibliography}

\end{document}